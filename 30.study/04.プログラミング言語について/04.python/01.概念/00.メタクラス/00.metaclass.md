# メタクラスとは

## Python の class これによって成り立っている

* クラスはOBJ。
* 他のOBJ と同様、何かのインスタンス
* クラスは、メタクラスのインスタンス
* デフォルトのメタクラスは `type`
* インスタンスは クラスのインスタンス。クラスはメタクラスのインスタンス。という関係
* 下記でクラスを作成できる

```py
MyClass = type('MyClass', (), {})
```



## カスタム メタクラスを作って、それで class を作る

```py
class Meta(type):
  pass
```

```py
class Complex(metaclass=Meta):
  pass
```


## struct
* C 言語とその派生における struct(構造体)の特徴
* グループ化した変数のリストを、一つのメモリのブロック上に、一つの名前のもとに配置したもの
* 一つのポインタ、またはそのstructのアドレスを返す宣言名で、異なる変数にアクセスできる




## The slots
* クラスのマジックメソッドを定義する
* 結果、その関数は、事実上そのクラスを表す struct に対するポインタになる
* 上記 struct は各マジックメソッド用のフィールドを持つ
* 上記フィールドを type slot と呼ぶ
* type slot と __slots__ は同一ではない






## Object attribute lookup(OBJ が該当属性をどうルックアップするか)
* Class というクラスがあるとする
* instance は Class クラスのインスタンスだとする
* instance.foobar を評価するとき、その OBJ の attribute lookup が行われる

1. Class.__getattribute__ の type slot が呼ばれる
2. Class.__dict__ には __get__ メソッドとデータ descriptor のある foobar というアイテムがある？
 →ある → Class.__dict__['foobar'].__get__(instance, Class) の結果を返す

3. instance.__dict__ には foobar アイテムがある？
 →ある →instance.__dict__['foobar'] の結果を返す

4. Class.__dict__ には データ descriptor ではない foobar アイテムがある？
 →ある →Class.__dict__['foobar'].__get__(instance, Class) の結果を返す

5. Class.__dict__ には foobar アイテムがある？
 →ある →Class.__dict__['foobar'] の結果を返す

6. foobar という attribute がまだ見つからない場合
  Class.__getattr__ がある？
   →ある →Class.__getattr__('foobar') を実行する




## Class attribute lookup(クラス が該当属性をどうルックアップするか)
* クラスは classmethod と staticmethod プロパティをサポートする必要がある

* Class.foobar みたいなのを評価するとすると、instance.foobar を評価するときとルックアップの挙動は少し異なる

* Class は Metaclass のインスタンスだとする
* Class.foobar は下記のように行われる


1. Metaclass.__getattribute__ (tp_getattro) が呼ばれる

2. Metaclass.__dict__ に foobar アイテムが有り、かつそのアイテムには __get__ メソッドがあり、そのアイテムは data descriptor か？
 →Yes →Metaclass.__dict__['foobar'].__get__(Class, Metaclass) の結果を返す

3. Class.__dict__ には foobar アイテムが有り、それは descriptor の一種？
 →Yes →Class.__dict__['foobar'].__get__(None, Class) の結果を返す

4. Class.__dict__ には foobar アイテムがある？
 →Yes →return Class.__dict__['foobar']

5. Metaclass.__dict__ は foobar というアイテムがあり、かつそれは data descriptor ではない？
 →Yes →Metaclass.__dict__['foobar'].__get__(Class, Metaclass) の結果を返す

6. Metaclass.__dict__ は foobar アイテムを持っている？
 →Yes →return Metaclass.__dict__['foobar']

7. まだ attribute が見つからない かつ Metaclass.__getattr__ が存在する？
 →Yes →Metaclass.__getattr__('foobar') をコール


## The slots
* クラスのマジックメソッドを定義する
* 結果、その関数は、事実上そのクラスを表す struct に対するポインタになる
* 上記 struct は各マジックメソッド用のフィールドを持つ
* 上記フィールドを type slot と呼ぶ
* type slot と __slots__ は同一ではない



## Magic method lookup
* マジックメソッドのｍルックアップは、クラスで行われる
* Struct の slot に対して直接見に行く

1. その オブジェクト のクラスにはマジックメソッドのスロットがあるか？ (roughly object->ob_type->tp_<magicmethod> in C code)?
 →Yes →使う。
 →Null →その処理はサポート外

# C の内部の用語では
object->ob_type これが、オブジェクトのクラス
ob_type->tp_<magicmethod> これが、タイプスロット
