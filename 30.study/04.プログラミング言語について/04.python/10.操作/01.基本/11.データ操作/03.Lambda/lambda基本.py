▼ Lambda
# 関数をいちいち定義せず、アノニマス関数を作成できる。
# ただし、単一の expression にのみ使用するもの。
#
# ブロック内で複数のタスクを走らせる場合は、関数を定義しましょう。

▼ syntax
lambda 引数: 返り値

-------------------------------------------------
list(map(lambda x: (9/5)*x + 32, temps))
-------------------------------------------------
list(filter(lambda n: n % 2 == 0,nums))
-------------------------------------------------
add = lambda x, y : x + y

print add(2, 3) # Output: 5
-------------------------------------------------
dict_a = [{'name': 'python', 'points': 10}, {'name': 'java', 'points': 8}]

map(lambda x : x['name'], dict_a) # Output: ['python', 'java']

map(lambda x : x['points']*10,  dict_a) # Output: [100, 80]

map(lambda x : x['name'] == "python", dict_a) # Output: [True, False]
-------------------------------------------------
list_a = [1, 2, 3]
list_b = [10, 20, 30]

map(lambda x, y: x + y, list_a, list_b) # Output: [11, 22, 33]
-------------------------------------------------
dict_a = [{'name': 'python', 'points': 10}, {'name': 'java', 'points': 8}]

filter(lambda x : x['name'] == 'python', dict_a) # Output: [{'name': 'python', 'points': 10}]

-------------------------------------------------








■■■■■■■■■■■■■■■■■■■■■■■■■■ 要件:リストの要素のうち、3 で割り切れる値を mult3 に代入せよ

▼ Lambda を使わない例
-------------------------------------------------
# 引数が 3 で割り切れるかどうかを返す
def filterfunc(x):
    return x % 3 == 0

# 第二引数のリストのうち、第一引数のフィルター関数で TRUE となる要素を左辺に渡す
mult3 = filter(filterfunc, [1, 2, 3, 4, 5, 6, 7, 8, 9])
-------------------------------------------------

▼ Lambda
# Functional プログラミング
# ・関数を他の関数に渡す
-------------------------------------------------
# filter にて、x%3 == 0 という関数を第一引数として定義し、第二引数のリストをフィルタリングする
mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])
-------------------------------------------------

▼ list comprehension を使う例
-------------------------------------------------
# リストを for ループし、3 で割り切れる要素のみを左辺に渡す
mult3 = [x for x in [1, 2, 3, 4, 5, 6, 7, 8, 9] if x % 3 == 0]
-------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■ Function wrapper
# 引数にn を足す Lambda 関数を返す関数
>>> def transform(n):
...     return lambda x: x + n
# x + 3 を返す関数を、f に代入
>>> f = transform(3)
# 上記関数に x として 4 を渡す --> 4 + 3 を返す
>>> f(4)
7



■■■■■■■■■■■■■■■■■■■■■■■■■■ シークエンスの要素を、reduce() を使って連結させる
# 1, 2 →1,2,3 →1,2,3,4.... -->1,2,3,4,5,6,7,8,9
>>> reduce(lambda a, b: '{}, {}'.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])
'1, 2, 3, 4, 5, 6, 7, 8, 9'


>>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))
[5, 4, 6, 3, 7, 2, 8, 1, 9]
