■■■■■■■■■■■■■■■■■■■■■■■■■■ 動的型付けと静的型付け
プログラム言語では、2種類の変数や関数を扱うタイプが存在する

■■■■■■■■■■■■■■■■■■■■■■■■■■ 動的型付け
・プログラムが勝手に「型」を定義つけてくれる
・プログラムを書くときに変数や関数に何が入ってくるかというのが特に決まっていない
・インタプリタで実行される言語は、ほぼこの形式を採用
・型を宣言する必要がないため、小さいプログラムや型の変動が激しい環境であれば簡単に実装できる
・動的型付けは事前コンパイルができない＝実行しないとバグがわからない
-------------------------------------------------
function add( a, b )
{
    return a + b;
}
-------------------------------------------------
▼ 下記はすべて機能する
-------------------------------------------------
// javascript
1. add( 1, 5 ); // 6
2. add( 1.5, 3.2 ); // 4.7
3. add( 3, 3.5 );   // 6.5
4. add( "1", "5" );  // "15"
5. add( "hoge", "hoge" ); // "hogehoge"
6. add( [1, 3, 5], [6, 8, 9] ); // 1,3,56,8,9
-------------------------------------------------


▼ 静的型付け
・コードを書くときに、関数や変数について、ユーザーが「型」を手動で定義づける
・変数や関数に型を予め定義しておき、その型以外のデータを変数では使えませんというもの

▼ 静的型付け と 機械語
・静的型付けは、ネイティブコードに直接コンパイルできる言語はほぼ持っています。
・機械語というものに変換するには、型という情報がなければコンパイラは機械語に変換できない
・機械語に型という情報は厳密にはありません。
・メモリ領域上で、その変数の情報にどのぐらいのメモリを確保し、そのデータはどのように扱うものなのかという判別が出来るぐらい

▼ コンパイラの機械語出力
-------------------------------------------------
int a; // (4byte)
double b; // (8byte)
char c[6]; // (6byte)
-------------------------------------------------
・上記をコンパイルする
 →メモリに順に 4, 8, 6 byteのメモリを確保するコードが出力される
  ※メモリでの操作を行うコードはコンパイルされたコードに含まれています。
  ※ このとき、4，8，6 が扱うデータがどのようなものであるか、という情報はなくなっています。
  ※ そこにあるのは、あくまで数値なデータだけです。




■■■■■■■■■■■■■■■■■■■■■■■■■■ Typing
“When types are checked” // 型チェック

例)
"3" + 5
▼ 強い型言語だと、エラーになる// such as Python and Go,
なぜか
型強制 させないから// 文脈を読んで、値の方を暗黙的に変えること  ※ + を使って異なる型同士をマージしたり

▼ 弱い型言語だと、エラーにならない// such as JavaScript // 例の 演算だと、35 になる



■■■■■■■■■■■■■■■■■■■■■■■■■■ ソースコードが翻訳される時の流れ

▼ Source Code:
Original code (usually typed by a human into a computer)

▼ Translation:
Converting source code into something a computer can read (i.e. machine code)

▼ Run-Time:
Period when program is executing commands (after compilation, if compiled)




■■■■■■■■■■■■■■■■■■■■■■■■■■ Compiled vs. Interpreted
・コンパイルされる場合と、インタープリタが使われる場合
▼ Compiled:
Code translated before run-time

▼ Interpreted:
Code translated on the fly, during execution


■■■■■■■■■■■■■■■■■■■■■■■■■■ 静的 VS 動的
▼ Static:
Types checked before run-time

▼ Dynamic:
Types checked on the fly, during execution


■■■■■■■■■■■■■■■■■■■■■■■■■■ 静的とコンパイル、動的とinterpreted
▼ it’s “when types are checked” vs. “when source code is translated”.

▼ "型チェック"は、その言語がコンパイルされているか、interpreted か、といったこととは隔離された概念



■■■■■■■■■■■■■■■■■■■■■■■■■■ Python Example // Dynamic, Interpreted
def foo(a):
    if a > 0:
        print 'Hi'
    else:
        print "3" + 5

foo(2)
-------------------------------------------------
・Python は インタプリタを使い、かつ動的型チェックがなされる
・上記例だと、else ブロックには到達しないため、型チェックはなされない

▼ もし、静的型付けだったとしたら？
・コード実行前に、タイプエラーが投げられる
・インタプリタ型だったとしても、実行前に型チェックがなされる、というわけ。

▼ もし、コンパイルされていたら？
実行前に、else ブロックが(機械語に)翻訳される
しかし
動的型付けだから、エラーは投げられない// そして、else ブロックには到達しない


■■■■■■■■■■■■■■■■■■■■■■■■■■ Go Example // Static, Compiled
package main

import ("fmt"
)

func foo(a int) {
  if (a > 0) {
      fmt.Println("Hi")
  } else {
      fmt.Println("3" + 5)
  }
}

func main() {
  foo(2)
}
-------------------------------------------------
・実行前に型チェックがなされる。静的だから。
 →型エラーがキャッチされる

▼ もし、インタプリタ型だったら？
実行前に型チェックされる。だから結果は同じ

▼ もし、動的だったら？
エラーは投げられない


■■■■■■■■■■■■■■■■■■■■■■■■■■ パフォーマンスの違い
・コンパイル言語のほうがよい。
なぜか
型が事前にわかっているため、機械語が最適化される
それに
実行時に機械語に翻訳しなくていいから


・静的言語のほうが良い
なぜか
実行時に動的型チェックしなくていいから

ただし、
コンパイルも、静的型チェックも、それらを実行する際に時間がかかる

■■■■■■■■■■■■■■■■■■■■■■■■■■ エラーチェック
・静的型チェックは、早めにエラーがわかる
※ 長いプログラムの場合は、こっちのほうが助かる
・プログラムのどこであろうと、型エラーがあるとエラーになる
※ 動的の場合は、型エラーの箇所に到達しなければ、実行時にもエラーにならない

■■■■■■■■■■■■■■■■■■■■■■■■■■ 型変更
・静的型チェックの場合、型変更できない // 下記のようにエラーになる
-------------------------------------------------
num = 2
num = '3' // ERROR
-------------------------------------------------

・動的型チェックの場合
柔軟
だがしかし
型変更の結果、予期せぬエラーが発生しうる
