### 別関数がローカル変数のアドレスを返す
* 関数がローカル変数のアドレスを返しても、完全に安全








# ローカルスコープを抜けた後も存在し続けるローカル変数
* 下記コードでは、ローカル変数 v は f() が返されたあとも存在している。
* ポインタ p はまだローカル変数 v のアドレスを参照している。

```go
var p = f()

func f() *int{// pointer to int
  v := 1
  return &v
}
```






* f を呼び出すたびに、値は異なる。

```go
fmt.Println(f() == f()) // "false"`
```
* なぜなら、ポインタは変数のアドレスを含んでいる












## ローカル変数を域外から更新
* ポインタ引数 を関数に渡すと、その関数は、間接的に渡されたその変数を更新することができる。

* 下記関数。渡されたポインタを通じて、そのポインタの変数の値をインクリメントして、その変数の更新後の値を返す




```go
func incr(p *int) int {
    *p++ // increments what p points to; does not change p
    return *p
}



v := 1

incr(&v)              // side effect: v is now 2

fmt.Println(incr(&v)) // "3" (and v is 3)
```

* ある変数の アドレスを取得するたびに(またはポインタをコピーするたびに)、
* その(同じ)変数の新しいエイリアス(またはその値を同定する方法)を得ることになる。
* ※ たとえば、`*p` は v のエイリアス。
