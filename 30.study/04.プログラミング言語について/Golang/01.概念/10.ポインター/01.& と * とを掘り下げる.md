# & and *


* & オペレータは 変数のアドレスを生成する
* * オペレータはポインタが参照している値を取得できる






# var x int で & と *

* 変数が `var x int` と宣言されたとする

* x のポインタは、`&x`

* 「int に対するポインタ」という観点から `*int` ポインター to int と表現できる











## * 経由で変数の値を交信

* 変数 p に x のポインタ(つまりは変数のアドレス)を格納したとする。
* 「p points to x」だとか「p contains the address of x」といった言い方をする。


* 「x の値」を、「p に格納されているx のアドレス」を経由するかたちで `*p` と表現することができる
* p を経由して下記のように変数 x の値を更新したり読んだりできる



```go
// 変数 x に 1 をアサイン
x := 1


// 変数 p に x のポインタをアサイン
p := &x         // p, of type *int, points to x



// p のポインタが指し示す変数の値を出力
fmt.Println(*p) // "1"




// p のポインタが指し示す変数の値を更新
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```









## aggregate タイプの変数

* 「aggregate タイプの変数」 →例えば struct や array
* 「aggregate タイプの変数」のコンポーネント →struct のフィールドや array の要素
* 「aggregate タイプの変数」のコンポーネントもまた、変数である
* →よってアドレスがある。つまりポインタがある。




## ポインタと nil
* 変数というものは、「addressable values」 と表現されることもある。
* どんなタイプのポインタも、ゼロバリューは nil である
* p が変数をポイントしているならば、 p != nil は常に真である。




## ポインタを比較
* ポインタも比較ができる。

* 2つのポインタがイコールであるケースは、同じ変数をポイントしている場合と、ともに nil の場合のみである。
```go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```
