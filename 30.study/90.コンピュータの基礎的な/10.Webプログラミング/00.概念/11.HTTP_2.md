## HTTP/2 って本当にいいのか？
* パフォーマンスの改善は限定的
* ネットワークでパケット欠損が発生すると、 HTTP/1.1 と比べて著しくパフォーマンスが低下する






# HTTP/2 を使うにあたって

* 並列処理や、圧縮、バイナリ化などが HTTP/２ で導入された

* 結果、パフォーマンスがよい。テキスト特有のセキュリティ上の問題も、バイナリ化で回避できる



* HTTP/2 の利点を最大限活用するには、 HTTP/1.1 とはロジック部分も変える必要がある






-------------------------------------------------
## Request multiplexing：リクエストの多重化



* 一つのサーバから、Webファイルを 非同期で DL できる

* →round trip time (RTT) が減って、ロードが早くなる
![](/Users/yasuakishibata/Google_Drive/Referenced_by_markdown/lsfjoweiur.png)

-------------------------------------------------

# Compression of request headers ：リクエストヘッダの圧縮
* 冗長なヘッダフレームを圧縮する


* ▼ 仕組み
* HPACK の仕様を使って圧縮

* クライアントもサーバも、previous リクエスト のヘッダーのリストを保持する

* **圧縮** HPACK は各ヘッダの個別の値を、サーバに転送する前に圧縮する

* **サーバ側で検索** サーバは previously 転送されたヘッダの値のリストにある、エンコードされた情報を検索する

* **結果を持ってヘッダ再構築** 検索結果を使って、ヘッダ情報全体を再構築する
![](/Users/yasuakishibata/Google_Drive/Referenced_by_markdown/sdffsd.png)


-------------------------------------------------

# Binary protocol
* テキストプロトコル →バイナリプロトコルになった

* ▼ 利点(バグがヘリ、セキュリティ上の懸念も一つ消える)
* エラーが入り込みにくい
* レスポンス splitting 攻撃など、テキストであることに由来するセキュリティ上の懸念点がなくなる

* ▼ 利点(効率的になる)
* データをパースする際、オーバーヘッドが小さい
* ネットワークフットプリントが軽い
* ネットワークリソース利用が効率的
* バイナリだと、処理と実装がコンパクトになる
* クライアント サーバ 間でのデータ処理が効率的で堅牢になる
* ネットワークのレイテンシーが削減され、スループットが改善される

* ▼ 利点(他の利点がバイナリ化によって実現可能になる)
* compression, multiplexing, prioritization, flow control and effective handling of TLS などが、バイナリ化によって可能になる



* ▼ 仕組み
* テキストコマンドを使ってリクエスト レスポンスサイクルを処理していた
* →バイナリコマンド(0 and 1) を使って同じタスクを実行するようになった

* フレーム化の複雑さが緩和され、コマンドの実装がシンプルになった
* それまでは、テキストと、optional spaces がコマンドに入り混じっていた

* ▼ HTTP/2 を実装しているブラウザがすること

* テキストコマンドをバイナリに変換する
* 変換後、転送をする
![](/Users/yasuakishibata/Google_Drive/Referenced_by_markdown/skdfjowfe.png)

-------------------------------------------------
# HTTP/2 サーバ Push
* サーバからクライアントに、(リクエストされてないけど将来的に使うかもしれない、キャッシュ可能な追加情報) を送ることができる

* ▼ 例
* クライアントがリソース X をリクエストしたとする

* リクエストされた リソース X は、リソースY を参照していることがわかっているとする

* その場合、(クライアントからの追加リクエストを待たずに)サーバ側で、X と同時に Y もPush するかどうかを選択できる
![](/Users/yasuakishibata/Google_Drive/Referenced_by_markdown/skuowe.png)




* ▼ 利点
* クライアントはプッシュされたリソースをキャッシュできる
* クライアントは、キャッシュしたリソースを、異なるページで再利用できる
* クライアントは、プッシュされたリソースを「キャッシュしたリソースのレポジトリｊ



* サーバは 同じTCP接続内の「もともとリクエストされた情報」と、プッシュしたリソースを、 multiplex できる
The server can multiplex pushed resources along with originally requested information within the same TCP connection.




* サーバはプッシュしたリソースを prioritize できる





* クライアントはプッシュされたリソースを使わないことができる。キャッシュしたリソースのレポジトリを効率的に利用するために。または、サーバの Push を丸々無効化することができる。

* クライアントは、Push されたストリームの並列多重化数を制限することもできる


* ▼ レストランにおける客とウェイターの例

* HTTP/1.1 の場合、チャーハンとビールは別々のウェイターに注文する。2つの TCP コネクション。




* HTTP/2 の場合、2つ同時に注文できるが、持ってくるのは一つずつ

* クライアントはサーバに2つ同時にリクエストを送る
* サーバはアプリのロジックにリクエストを渡し、かつ2つのリクエストを一緒にクライアントに返す
* 結果、一つのTCPコネクションに、一つのリクエストを送るので、サーバの負荷は小さい
