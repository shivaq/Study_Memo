
## アーキテクチャの制約







### Client–server architecture
* the client–server constraints の背景にあるのは、the separation of concerns.

* ユーザーインターフェイスとデータストレージの Concern を分離することで、複数のプラットフォームにまたがったUIのポータビリティが改善される

* サーバコンポーネントがシンプルになることで、スケーラビリティも改善される

* セパレーションによって、コンポーネントがそれぞれ独自に進化できる。










### Statelessness
* The client–server communication は、リクエストの際にサーバに保存されたクライアントのコンテキストによる制約を受けたりしない

* あらゆるクライアントからの各リクエストには、そのリクエストに必要なすべての情報が含まれている。

* セッションの状態はクライアントが保持している

* セッション状態はサーバから別のサービス(DBなど)に転送される。結果セッションの期間状態がpersistent であり、認証も保持される。

* クライアントは、トランジションが新しい状態になる準備ができたときにリクエストを開始する。







### Cacheability
* WWW ではクライアントと中間のものどもはレスポンスをキャッシュできる。
そのため、レスポンスは、明示的にしろ暗示的にしろ、キャッシュできるものとして定義されなければならない、
または、
レスポンスは、クライアントがさらなるリクエストした場合も、古くなった/不適切なデータをレスポンスのときに受け取ることを妨げない。






### Layered system
* 通常、クライアントはエンドサーバと直接つながっているのか、仲介者とつながっているのか判断することができない
* 仲介サーバはシステムのスケーラビリティを、ロードバランシングと共有キャッシュによって改善することができる。
* 仲介サーバはセキュリティポリシーを強制することができる。







### Code on demand (optional)
サーバは以下の方法でクライアントの機能を拡張またはカスタマイズすることができる。
* Java アプレット、JavaScriptなどのクライアントサイドスクリプト
