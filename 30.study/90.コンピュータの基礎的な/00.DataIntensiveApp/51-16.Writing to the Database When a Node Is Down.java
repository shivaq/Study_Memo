■■■■■■■■■■■■■■■■■■■■■■■■■■ Writing to the Database When a Node Is Down
たとえば
3つのレプリカがあるデータベースがあるとする。
そのうちひとつのレプリカが 使用できない状態だとする
システムをアップデートするためなどの理由で。

▼ In a leader-based configuration,
書き込み処理を続けたければ、フェイルオーバーする必要がある。

▼ in a leaderless configuration
・フェイルオーバーが、存在しない。
たとえば
クライアントが3つのレプリカに、パラレルで書き込みを送ったとする。
2つのレプリカは書き込みを受け付けるが、
使用できないレプリカは、それを受け取れない。

たとえば、
書き込みがなされたと判断するには、
3つのレプリカのうち2つがあれば十分だとする
ユーザーが書き込みを行う
 →2つの OK レスポンスを受け取る
  →書き込みは成功したと判断する。
   →クライアントは、レプリカのうちひとつが書き込みを受け取れなかったことを無視する。

その後、
使用できないレプリカが復帰したとする。
クライアントがレプリカから読み込みをする
 →そのノードがダウン中の書き込みは、そのノードにはない
  →そのノードから読み込みをすると、古い値を受け取る可能性がある
そんな事象の解決策
クライアントがDBから読み込みをするとき
 →複数のノードに同時に読み込みリクエストを送る
  →クライアントは異なるノードから異なるレスポンスを受け取るかもしれない
その時、どの値がより新しいのかを、バージョン情報から判断したりする。

■■■■■■■■■■■■■■■■■■■■■■■■■■ Read repair and anti-entropy
・レプリケーションスキーマというものは、
最終的にすべてのデータが全てのレプリカにコピーされることを保証しなくてはならない。

ダウンしたノードが復帰したとき、どうやってミスした書き込みに追いつくのか。
Dynamo スタイルデータストアでよく使われる方法は以下の2つ

▼ Read repair
クライアントが、複数のノードからパラレルで読み込みを行うタイミングで、
古いレスポンスを検知するようにする。
たとえば、
あるユーザーがレプリカ3からバージョン6の値を受け取ったとする
そして、
レプリカ1,２からバージョン７の値を受け取ったとする。
クライアントは、レプリカ３は古い値を保持していると判断する
 →新しい書き込みを、レプリカ３に書き戻す

上記アプローチは、読み込みが頻繁な値にはいい感じに機能する

▼ Anti-entropy process
データストアによっては、
レプリカとコピーとのデータの違いを、バックグラウンドプロセスでコンスタントにチェックしている物がある。

リーダーベースレプリケーションとちがって、
anti-entropy process は書き込みを、特定の順序でコピーしたりしない。
で、
データをコピーするときは、遅延が大きい可能性がある。

全てのシステムが、上記両方を実装しているわけではない。

Voldemort は現状 anti-entropy process を採用していない。

・アンチエントロピープロセスがない場合
めったに読み込みがなされない値は、レプリカから失われる可能性がある。
結果、
耐久性が損なわれる
なぜならば、
リードリペアがなされるタイミングは、
アプリが値を読み込んだときだけだから。

■■■■■■■■■■■■■■■■■■■■■■■■■■ Quorums for reading and writing
Quorums：定足数 とは

３つのレプリカのうち２つの書き込みが成功すれば、書き込み成功と判断するシステムで、
3つのレプリカのうち一つのレプリカだけが書き込みを受け取ることができた場合、
どうするの？

３つのうち２つのレプリカでは、全ての書き込みが最新である、ということが保証できた場合、
最大一つのレプリカでは、古い値であるということを意味する。// 未確認ではあるが。

少なくとも２つのレプリカさえ読み込めば、
２つのうち少なくとも１つが UpToDate であることが保証できる。

もし３つ目のレプリカがダウンしてたり、レスポンスが遅かったりする場合でも、
読み込みによって UpToDate な値を返すことができる。

▼ より 一般化した表現をすると w + r > n
n replicas があるとする。
全ての書き込みは w 個のノードによって確認される必要があるとする。
書き込みが成功したと確認するには、
各書き込みごとに、少なくとも r 個のノードに対してクエリしなければならない。
(In our example, n = 3, w = 2, r = 2.)

w + r > n // 書き込み成功 + 読み込み成功 > レプリカ数
上記である限り、読み込み時に UpToDateなデータを取得できると期待できる。
なぜならば、
r 個のノードのうち少なくとも１つは UpToDate だと言えるから。

上記を満たす Read と Write のことを、
quorum reads and writes
と呼ぶ。

r and w のことを、
読み書きが valid だとするために必要な最小得票数だと考えることもできる。

-------------------------------------------------
ダイナモスタイルのDBでは、
n, w, and r はたいてい変更可能。

▼ common choice
n を奇数とする。(typically 3 or 5)
で、
w = r = (n + 1) / 2 (rounded up)

▼ 書き込みが少なくて読み込みが多い場合に適したバランス
w = n and r = 1
結果、
読み込みが早くなる
しかし
ノードが一つ failすると、全てのDBの書き込みが fail する。 // w + r > n：3 = 3, r = 1: 2 + 1 > 3 -> false

▼ クラスタが n 以上のノードがあっても、データは n 個のノードにのみ格納される
クラスタには、 n 以上のノードがあるかもしれない。
しかし、
受け取った値は n 個のノードにしか格納されない。
こうすると、
データセットが partitioned される。
partitioned されると、
一つのノードにフィットする以上のサイズのデータセットが扱える。
partitioning についてはまた後で触れる。

■■■■■■■■■■■■■■■■■■■■■■■■■■ w + r > n の場合に許容される unavailable nodes
・w < n の場合、一つのノードが駄目でも、書き込み処理はできる
・r < n の場合、一つのノードが駄目でも、読み込み処理はできる
• With n = 3, w = 2, r = 2、一つのノードが駄目でも大丈夫
• With n = 5, w = 3, r = 3、２つのノードが駄目でも大丈夫
・通常、読み書きは n 個のレプリカ全てにパラレルで送られる。
w and r は、いくつのノードの成功報告が必要か、を決める
たとえば、
読みまたは書きが成功したと判断する前に、
n 個のノードのうち、いくつのノードが 成功したと報告する必要があるか。

▼ もし、有効な報告が必要な w or r に満たない場合
読みまたは書きはエラーを返す。
・我々は、ノードが成功レスポンスを返すかどうかだけを気にすればよく、fault の種類の違いを判別する必要はない

▼ unavailable の主な理由
・the node is down (crashed, powered down)
・操作の実行エラー
(can’t write because the disk is full)
・クライアント ノード間のネットワーク問題
