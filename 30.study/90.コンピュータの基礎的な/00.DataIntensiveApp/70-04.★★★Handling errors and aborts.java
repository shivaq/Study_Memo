■■■■■■■■■■■■■■■■■■■■■■■■■■ Handling errors and aborts
・トランザクション の大きな強みは、
エラー発生時に、トランザクションを破棄して安全にリトライできることだ。

ACID なDBの根本哲学：
もしDBがAIDが崩される危険性にさらされた場合、
半分でトランザクションを終わらせるよりは、トランザクション全体を破棄するほうが良い。

すべてのシステムが上記哲学に従っているわけではない。
特に、
リーダーレスレプリケーションを行うデータストアの場合、
ベストエフォートで対応している。
そしてそのスタンスはこう表現できる

データベースはできるだけのことはします。
もしエラーになったときは、実施済みの処理を Undo したりしません。
よって、エラーからリカバーする責任は、アプリ側にあります。

▼ エラーは不可避的におこる。
だが、多くの開発者は、
例外処理の複雑さに取り組むよりは、the happy path だけを考えることを好む。

例えば、Rails’s ActiveRecord and Django といった
object-relational mapping (ORM) frameworks は、
破棄されたトランザクションのリトライをしない。
the error usually results in an exception bubbling up the stack
結果、
ユーザーのインプットは破棄され、エラーメッセージが表示される。

これは、はずべきことですぞ。
なぜかというと、
トランザクションが破棄されるのは何のためかというと、安全なリトライを行うことができるようにするためなのだから
-------------------------------------------------
▼ 破棄されたトランザクションのリトライは、シンプルで有効な例外処理メカニズムだが、完璧ではない


・トランザクションは成功したとする。
だがサーバーがコミット成功をクライアントに ack しようとする前に、ネットワークが fail して、
(クライアントはコミットにfail したと判断して)トランザクションをリトライしたとする。
結果、(アプリレベルで重複対処のメカニズムがない限り)二度トランザクションが実行されることになる。

・エラー原因が 高負荷 だった場合、トランザクションのリトライは問題を更に悪くする。
こういったフィード・バックサイクルを回避するために、
you can limit the number of retries,
use exponential backoff,
and handle overload-related errors differently from other errors (if possible).

・一時的エラーのあとでリトライすると、状況は悪くなるだけだ
(for example due to deadlock, isolation violation, temporary network interruptions, and failover);
・永続的エラーのあとでリトライしても意味はない(e.g., constraint violation)

・トランザクションに DBの外側での side effects がある場合、トランザクションが破棄されてもそれら side effects は起きるかもしれない。
例えば、
メールを贈ろうとしているとする。
トランザクションがリトライされるたびに、メールを再送信したくない。
もし、
複数の異なるシステムが、コミットまたは破棄を、一緒に行うことを確かにしたいのならば、
 two-phase commit が有効かもしれない。

・リトライ中にクライアント側のプロセスが失敗したら、DBに書き込もうとしていたデータは欠損する。
