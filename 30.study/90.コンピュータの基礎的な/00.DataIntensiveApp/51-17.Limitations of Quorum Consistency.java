■■■■■■■■■■■■■■■■■■■■■■■■■■ Limitations of Quorum Consistency
n と r と w が「w + r > n」のように決まれば、
下記のように考えていい。

全ての読み込みは、そのキーに対して書き込まれた最新の値を返す、ということ。

なぜそう言えるか。

あなたが書き込んだ一連のノードと、
読み込みを行ったノードとは、
オーバーラップしているに違いないから。
そうすると、
読み込んだノードのうち、少なくとも１つのノードが最新の値を持っているに違いないから。

▼ たいてい、r と w はノードのマジョリティ(more than n/2)となるように選ばれる
そうすれば、
w + r > n
が保証されるし、
n/2 までであれば、 failure しても大丈夫だから。

▼ quorums はマジョリティでなくても構わない
・読みと書きの操作で使われるノードがオーバーラップしているかどうか、だけが重要だ。
・quorum の設定によって、分散アルゴリズムを設計する上での柔軟性が許容される。

■■■■■■■■■■■■■■■■■■■■■■■■■■ w + r ≤ n という設定もありうる
 →quorum の条件は満たせない
こうなると
読み と 書き とは n 個のノードに送られる
しかし
成功と判断される条件として、より小さい数の成功レスポンスだけが要求される

▼ 欠点
古い値を読み込む可能性が高くなる
なぜなら
ある読み込みが、最新の値を保持するノードを含まない可能性が高くなるから

▼ 利点
レイテンシーが低くなる
可用性が高くなる
なぜか
ネットワークの中断があったとして、、
多くのレプリカが未達になったとしても、
読み書き処理を続けられる可能性が高くなる

DBが 読み書き unavailable になる条件は、
到達可能レプリカが、 w または r を下回った場合のみ

■■■■■■■■■■■■■■■■■■■■■■■■■■ w + r > n でも古い値が返ってくるエッジケース
実装による。

・Sloppy Quorums(後述する)が使われた場合、w の書き込みが、r の読み込みノードとは別のノードになされる可能性がある。
結果、読み と 書き のノードがオーバーラップすることが保証できない

・２つの書き込みが同時に起きた場合
 →どちらが先に書き込まれたかが不明確となる
唯一の安全な解決策
 →同時書き込みをマージする
タイムスタンプで勝者を決める場合
 →クロックの歪みの結果、書き込みがロストする可能性がある

・読みと書き込みが同時に起きた場合
 →書き込みはレプリカの一部にしか反映されないかもしれない
 結果、読み込みが新しい値を返したのか、古い値を返したのかはわからない

・書き込みが、あるレプリカでは成功して、他のレプリカでは失敗した場合 // ディスクフルなどの理由で
かつ
成功した書き込みが w より小さい場合
成功したレプリカにはロールバックしない
and overall succeeded on fewer than w replicas,
it is not rolled back on the replicas where it succeeded.
こうなると
書き込みが fail と報告された場合、
続く読み込みは、その書き込みから値を返すかも知れないし、返さないかもしれない。

・新しい値を保持しているノードが failして、
そのデータがリストアされる時に、古い値を保持しているレプリカからリストアされた場合、
新しい値を保持するレプリカの数が、 w を下回って quorum 条件が破綻する可能性がある。

・全てうまくいったとしても、Linearizability and quorums みたいな タイミングに合致してしまうかもしれん

-------------------------------------------------
quorums が、読み込み時に最新の書き込みの値を返すことを保証しているように見えても、
そう単純じゃない。

Dynamo-style データベースは、「eventual consistency」を許容するようなユースケースに最適化している。
w and r のパラメータは、古い値を読む可能性を調整できるが、絶対視しないほうがよい。

Stronger guarantees generally require transactions or consensus.


■■■■■■■■■■■■■■■■■■■■■■■■■■ Monitoring staleness
・DBが UpToDate な結果を返しているかどうかモニタリングすることは重要。
あなたのアプリが古い読み込みを許容するとしても、
レプリケーションのヘルスには気をつけたほうがいい。
ヘルスが著しく低下した場合は、アラート発報して、原因調査をすべき。

▼ リーダーベースレプリケーションの場合、
DBはたいていレプリケーションラグのメトリクスを提供しているので、
必要に応じてモニタリングシステムに読み込ませると良い。
どうしてメトリクスを提供できるかというと、
書き込みはリーダーとフォロワーとに、同じ順番で適用される
そして
各ノードはレプリケーション ログにポジションを持っている
(the number of writes it has applied locally)
で、
リーダーの現在のポジションから、フォロワーの現在のポジションを差し引くことで、
レプリケーションラグを計算できる。

▼ リーダーレスレプリケーションの場合
書き込みがなされる順番は fix されない。
なので、モニタリングは難しい。
さらに、
DB が read repair しか使っていない場合、
値の古さに限度がないので、
読み込みが頻繁でない場合、読み込み時に返ってくる値がちょー古い可能性もある。

▼ リーダーレスでの、レプリカの古さをモニタリングする方法は模索されてはいる
the parameters n, w, and r を使って、
古い読み込みのパーセンテージを予測する試みがいくつかある。
しかし、
まだ一般的ではない
それでも、
DBの標準メトリクスに staleness を含めることは良いことといえる。

▼ Eventual consistency
は、
どれくらい保証されているかが曖昧
しかし、
オペレーションの観点からは、
“eventual.” を数値化できることは重要です。
