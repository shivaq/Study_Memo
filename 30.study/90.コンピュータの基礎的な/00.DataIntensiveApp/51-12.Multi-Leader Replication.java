■■■■■■■■■■■■■■■■■■■■■■■■■■ Multi-Leader Replication
▼ Leader-based replication の欠点
・リーダーが一つだけの場合、
全ての書き込みはそこになされなければならない。
ネットワーク上の問題などによって、リーダーに接続できなくなったら、
DBへの書き込みができないことになる。

▼ multi-leader configuration (also known as master–master or active/active replication)
・複数ノードに書き込みができたらいいじゃない。
・各ノードが処理した書き込みは他のノードに伝播しなければならない。
・各リーダーは、他のリーダーのフォロワーでもある。

▼ Use Cases for Multi-Leader Replication
・単一のDC で、マルチリーダーを採用するメリットはあまりない。
追加される複雑さのほうが、便益より大きくなるから。
では、マルチリーダーが合理的選択となるケースとは、どんなケースなのだ？

■■■■■■■■■■■■■■■■■■■■■■■■■■ Multi-datacenter operation
・DBとそのレプリカが複数のDCにまたがっているケース。
※ 高可用性のため、または地理的に離れたユーザーに対応するため。
・各DCにリーダーを配置できる。

▼ 各DC内
通常の、リーダー、フォロワーレプリケーションが行われる

▼ 異なるDC間
・各DCのリーダーが、他のDCのリーダーとの間で 変更部分をレプリケートしあう。

Let’s compare how the single-leader and multi-leader configurations fare in a multi- datacenter deployment:
■■■■■■■■■■■■■■■■■■■■■■■■■■ マルチDC環境での単一リーダー VS マルチリーダー
▼ Performance
・In a single-leader configuration
あらゆる書き込みが、リーダーのあるDCにいかなければならない。
レイテンシーは高いし、マルチDCにする意味がない。

・multi-leader configuration
各書き込みはローカルDCで処理され、他のDCに非同期でレプリケートされる。
結果、
DC間ネットワーク遅延はユーザーから隠蔽され、体感パフォーマンスは良くなる。

▼ Tolerance of datacenter outages

・In a single-leader configuration
リーダーが fail する
 →他のDCのフォロワーがリーダーになる

・In a multi-leader configuration
各DCは、他のDCと独立して継続運用し続ける。
fail したDCが復帰すると、レプリケーションがキャッチアップされる。

▼ Tolerance of network problems
・DC間のトラフィックは通常インターネット経由で行われる。
DC内のローカルネットワークと比べて信頼性は低い

・A single-leader configuration
DC間リンクの状態に敏感。
なぜなら、
書き込みはリンクを通じて同期されるから。

・A multi-leader configuration
非同期レプリケーションなので、一時的ネットワークイシューがあっても、
書き込み処理を妨げない。

▼ マルチリーダー configuration サポート
・DBによってはデフォルトでサポート
・外部ツールによる実装
Tungsten Replicator for MySQL
BDR for PostgreSQL
GoldenGate for Oracle

▼ マルチリーダーの欠点
・欠点がある。だから、可能な限りマルチリーダーは避けるべきとされている。デンジャーゾーン
それでも、マルチリーダーがフィットするユースケースはあるし、紹介はしていく。

・同じデータが異なるDC内で個別に同時に変更される可能性がある。
そしてそれらコンフリクトは解決されなければならない

・マルチリーダーレプリケーションは、多くのDBにとって後付フィーチャー
よって
設定上の落とし穴や、他のフィーチャーとの間の干渉などの問題がある
例えば
autoincrementing keys, triggers, and integrity constraints


■■■■■■■■■■■■■■■■■■■■■■■■■■ Clients with offline operation
・アプリがオフラインの状態でも機能してほしい場合、マルチリーダーは選択肢としてあり。
たとえば
マルチデバイスで使うカレンダーアプリ
デバイスがオンラインかどうかにかかわらず、
see your meetings (make read requests)
enter new meetings (make write requests)
ができなければならない。

・オフラインで変更を加えた場合、
次にオンラインになったタイミングで
サーバと他のデバイスたちと、同期がなされなければならない。

・この場合、各デバイスはローカルDBを持っている。
そのDBはリーダーとして振る舞う。
そのリーダー間では、非同期マルチリーダーレプリケーションが行われる。

・レプリケーション遅延は数時間、数日にもなる。

・カレンダーアプリのこうしたアーキテクチャーは、
マルチDCのマルチリーダーレプリケーションと本質的に同じである。
各DC間のネットワーク接続は極めて unreliable である。
そして、カレンダーアプリの同期の実装の歴史は、マルチリーダーアプリを正しく構築することの難しさの歴史でもある。

・マルチリーダー設定をサポートするツール
CouchDB

■■■■■■■■■■■■■■■■■■■■■■■■■■ Collaborative editing
▼ Real-time collaborative editing applications
・Google Docs とか。

・共同編集は、オフラインで機能するアプリと同じ、DBレプリケーション問題を抱えている。
あるユーザーがドキュメントを編集する
 →変更はそのユーザーのローカルレプリカに即座に適用される // ブラウザ上、クライアントアプリ上のドキュメントに。
  →非同期で、サーバーと、同じドキュメントを編集しているユーザーとにレプリケートされる。

・編集時のコンフリクトが発生しないことを保証したい場合
アプリは、ユーザードキュメントを編集する前に、ロックを取得しなければならない。
他のユーザーが同じドキュメントを編集したいとする。
そのユーザーは、最初のユーザーが変更をコミットし、ロックを解放するのを待たなければならない。

このコラボレーションモデルは、
単一リーダーレプリケーションにおける、リーダー上位のトランザクションと同じ。

▼ スピーディーなコラボレーションがしたい場合
"変更"の単位を小さくする // シングルキーストロークとか
そして、ロックを回避する。
結果、
複数のユーザーが同時に編集する事ができるようになる。
だがしかし、
マルチリーダーレプリケーションのあらゆる問題に対処しなければならない。
コンフリクト解決とか。
