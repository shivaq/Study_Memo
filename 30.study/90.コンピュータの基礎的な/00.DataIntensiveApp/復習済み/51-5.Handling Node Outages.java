■■■■■■■■■■■■■■■■■■■■■■■■■■ Handling Node Outages
・システムのノードには、ダウンする可能性がかならずある
faultや計画的メンテナンスなどの理由で
※ カーネルのセキュリティパッチを当てるために、サーバを再起動するなど

・個々のノードを、ダウンタイム無しでリブートしたい。
そして、ノードの機能停止のインパクトを最小化したい。
で、どうやってそれを実現するのだ？

▼ Follower failure: Catch-up recovery
各フォロワーは、そのローカルディスクに、リーダーから受信したデータ変更のログを保持しておく
・もしフォロワーがクラッシュ →再起動した場合、またはリーダーとの間のネットワークが一時的に中断したら
↓
フォロワーは、最後に処理したトランザクションをログから確認できる
 →フォロワーはリーダーに接続する
  →接続できなくなった時点以降のデータ更新情報をリーダーにリクエスト
   →変更を反映 →リーダーに追いついた。

▼ Leader failure: Failover
・フォロワーのいずれかが新しいリーダーに昇格しなければならない
・クライアントは書き込みを新しいリーダーに贈るよう再設定しなければならない
・他のフォロワーたちは新しいリーダーのデータ変更を consume しなければならない

・Failover は手動で行う場合もあれば、自動でなされる場合もある

▼ 自動フェイルオーバーステップ
1. リーダーが fail したかどうかを判断する
原因はいろいろ考えられる
crashes, power outages, network issues, and more.
しかし、
何が起きていたのか確実に判断する方法はない。
よって、ほとんどのシステムは"タイムアウト"を使う

・ノードは互いに頻繁にメッセージをバウンスしあっている。
もしノードが一定時間(30秒とか)反応なかったら、
そのノードは死んだぜ？と判断される

2. 新しいリーダーの選出
通常、前リーダーの最新のデータ変更を保持するレプリカが選ばれる。
・consensus problem
 →すべてのノードが新リーダーに合意する際の問題

3. システムが、新リーダーを使うよう再設定する
・クライアントは書き込みリクエストを新リーダーに送る必要がある // “Request Routing”
・古いリーダーが復帰したとき、
 →クライアントが、それがまだリーダーだと認識したら困る
  →システムは旧リーダーがフォロワーに転じること、そして新しいリーダーを認識することを保証する必要がある。


■■■■■■■■■■■■■■■■■■■■■■■■■■ Failover is fraught with things that can go wrong:
▼ 非同期レプリカが使われている場合
新リーダーは旧リーダーが fail する前に、全ての書き込みを受け取っていない可能性がある。
 →もし前リーダーが、新リーダー選出後にクラスタに参加したら、書き込みはどうなる？
  →新リーダーはその期間所書き込みを受信してコンフリクトが起きるかも知れない。
一般的な解決策
 →旧リーダーの未レプリケート書き込みを破棄する
 →結果、クライアントの耐久性の要求は損なわれるが。

▼ 外部のストレージシステムがDBのコンテンツと連携している場合、書き込みの破棄は危険
"GitHub インシデント"
古いMｙSQLフォロワーがリーダーに昇格した。
そして、そのDBは新規 row のPKにオートインクリメントのカウンターを割り当てていた。
しかし
新リーダーのカウンターは旧リーダーのカウンターより遅れていた
 →新リーダーは旧リーダーによって割り当て済みのPKを再利用する結果となった
さて、
そのPKはRedisストアでも使われていた。
 →結果、PK の再利用は MySQL and Redis の間の inconsistency の結果となった。
  →結果、プライベートデータの一部が、別のユーザーに開示されてしまった

▼ split brain
2つのノードが、自身を新リーダーだと認識する事態が発生しうる。
2つのリーダーが書き込みを受け付けるとする
 →コンフリクトを解決するメカニズムがないとする
  →結果、データはロストするか、壊れてしまう
予防策として
 →2つのリーダーが検知された場合、一つのノードをシャットダウンする
使用上の注意
このメカニズムが慎重にデザインされていないと、
 →2つのノードがともにシャットダウンしてしまうこともあり得る。

▼ リーダー死亡宣言に至るためのタイムアウト値はどれくらいがよいのか
タイムアウトが長い場合
 →リーダー失敗時に復旧に時間がかかる
タイムアウトが短い場合
 →不必要なフェイルオーバーが発生する
※ 一時的負荷のスパイク →レスポンス時間がタイムアウトを上回る
 →または
  →パケット遅延を起こす
※ すでに高負荷やネットワーク問題を抱えているシステムの場合、さらに状況は悪くなる

・上記問題の簡単な解決策はない
よって
ソフトウェアが自動フェイルオーバーに対応していても、手動で行うことを好むチームもある

・ノードの 失敗や信頼できないネットワーク、
replica consistency, durability, availability, and latency のトレードオフは
分散システムの抱える運命的課題である
