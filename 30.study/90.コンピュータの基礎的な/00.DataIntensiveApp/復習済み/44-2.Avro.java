■■■■■■■■■■■■■■■■■■■■■■■■■■ Apache Avro
Avro は Protocol Buffers and Thrift とは異なったバイナリエンコーディングフォーマット。
・Thrift が Hadoop のユースケースとフィットしなかったので、Hadoop のサブプロジェクトとして始まった。
・エンコードされたデータの構造を指定するスキーマを使う

▼ ２つのスキーマ
・(Avro IDL) intended for human editing
-------------------------------------------------
record Person {
string userName;
union { null, long } favoriteNumber = null;
array<string> interests;
}
-------------------------------------------------


・(based on JSON) that is more easily machine-readable
-------------------------------------------------
{
    "type": "record",
    "name": "Person",
    "fields": [
{"name": "userName", "type": "string"},
{"name": "favoriteNumber", "type": ["null", "long"], "default": null},
{"name": "interests", "type": {"type": "array", "items": "string"}}
]
}
-------------------------------------------------
・エンコーディングは文字列を連結したもの、だけでできている。
・★★スキーマにタグ番号がない
・Example 4-1 をエンコードすると 32 バイト
・フィールドもデータタイプも同定するよすがが見えない
・int は Thrift と同様 variable-length encoding でエンコードされている

▼ どのようにパースしているか
・順番にフィールドを見ていく
・スキーマを使って、各フィールドのデータタイプを判別する
これって。。。
データを書いたコードと全く同じスキーマを使ったコードが、
該当バイナリデータを読み込んだときのみ、正確にデコードできる
スキーマが違ってたら正しく読めない。

▼ 読み手のスキーマ、書き手のスキーマは一緒じゃなくていい
Avaro でアプリがデータをエンコードする時 // ファイルやDBへの書き込み、ネットワーク越しにデータを送るなど
 →知っているバージョンのスキーマを使ってデータをエンコードする
 ※ 例えば、アプリにコンパイルされたスキーマ

アプリがデータをデコードする時 // ファイルやDBからの読み込み、ネットワーク越しの受け取りなど
そのデータは読み手が知っているスキーマであることを期待(前提と?)している
※ コードはアプリのビルドプロセス時に、そのスキーマを使って生成されてたりする

・Avro のキーアイデアは、書き手と読み手のスキーマは同じである必要はなく、
互換性さえあればいい、という考えだ。
・データがデコードされる時
 →Avro のライブラリが書き手と読み手のスキーマを見比べる
  →書き手のスキーマデータを読みてのスキーマに翻訳する。
・各スキーマのフィールドの順番が異なっていても問題ない。
 →フィールド名でスキーマの違いが解決される。
・書き手スキーマにあり、読みてスキーマにはないフィールドがあった場合は、そのフィールドは無視される。
・読み手のコードが期待するフィールドが、書き手のスキーマのフィールド名になかった場合、
 →読み手のスキーマが宣言したデフォルト値で埋められる




▼ Schema evolution rules(for Avro)
・前方互換性がある、ということは下記を意味する
 →書き手が新バージョンのスキーマを使う
  →読み手は古いバージョンのスキーマを使う

・後方互換性がある、ということは下記を意味する
 →読み手が新バージョンのスキーマを使う
  →書き手が古いバージョンのスキーマを使う

・互換性を維持するために
 →デフォルト値があるフィールドだけが、追加/削除することができる
例)
・デフォルト値付きの新規フィールドを追加する
(このフィールドは新スキーマにはある。旧スキーマにはない)
 →新スキーマの読み手が、旧スキーマのレコードを読む
  →旧レコードに存在しないフィールドには、デフォルト値が入る
例)
デフォルト値がないフィールドを追加する
 →新スキーマの読み手は旧スキーマのデータを読めない(後方互換性崩壊)
デフォルト値がないフィールドを削除する
 →旧スキーマの読みては、新スキーマのデータを読めない(前方互換性崩壊)


▼ Avro が null をどう扱うか
・null をただ入れるだけではうまくいかない仕様
・null をデフォルト値として扱うには、 union タイプにする必要がある
・union タイプの要素のうちの一つ、としてだけ null を使うことができる
・明示的に何がnull になりえて、何がなれないか、を指定する必要がある
 →結果、バグを防ぐことができる(と言える)

▼ Avro には optional and required マーカーがない
代わりに、Union タイプと デフォルト値 の組み合わせで表現する

▼ Avro はフィールドのデータタイプを変えることが可能
・ただし、Avro がそのデータ型を変換できる場合に限る

▼ Avro はフィールド名を変えることができないこともない
・読み手のスキーマは、フィールド名のエイリアスを含めることができる
 →旧書き手スキーマのフィールド名と、そのエイリアスとを照合することで解決する
  →結果、後方互換性は確保できる。前方互換性はできない。

▼ Union タイプに branch を追加できないこともない
 →後方互換性は確保できる。前方互換性はできない。
