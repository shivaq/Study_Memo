■■■■■■■■■■■■■■■■■■■■■■■■■■ Thrift and Protocol Buffers
▼ Apache Thrift と Protocol Buffers (protobuf)
・同じプリンシプルに基づいた、バイナリエンコーディングライブラリ
・エンコードされたあらゆるデータのスキーマが必要
・コード生成ツールと一緒に使う
 →各 IDL(interface definition language) をスキーマ定義として利用
  →渡されたスキーマを使って、各言語に応じたクラスを生成する
・アプリから、上記生成されたコードを呼び出して、レコードをエンコード/デコードできる

▼ Protocol Buffers
・originally developed at Google,

▼ Protocol Buffers interface definition language (IDL)
    message Person {
        required string user_name       = 1;
        optional int64  favorite_number = 2;
        repeated string interests       = 3;
}




■■■■■■■■■■■■■■■■■■■■■■■■■■ Thrift ■■■■■■■■■■■■■■■■■■■■■■■■■■
・originally developed at Facebook

▼ Thrift interface definition language (IDL)
struct Person {
1: required string userName,
2: optional i64 favoriteNumber,
3: optional list<string> interests
}

▼ Thrift がエンコードする祭のバイナリエンコーディングフォーマットは2つある
・BinaryProtocol and CompactProtocol

■■■■■■■■■■■■■■■■■■■■■■■■■■ 例
// MessagePack, a binary encoding for JSON
{
    "userName": "Martin",
    "favoriteNumber": 1337,
    "interests": ["daydreaming", "hacking"]
}
-------------------------------------------------


▼ BinaryProtocol
// 59 bytes
Figure 4-2 のようにエンコードされる。
・各フィールドには annotation(注釈)がつく。(to indicate whether it is a string, integer, list, etc.)
・必要に応じて、a length indication (length of a string, number of items in a list)
・文字列は、ASCII または UTF-8 にエンコードされる
・MessagePack のエンコードとの違い
 →names というフィールドがない
 →names (userName, favoriteNumber, interests)
・代わりに、tags フィールドがある
 →1, 2, and 3

スキーマの定義に、数値がある。
フィールドのタグは、エイリアスのようなもので、そのフィールドが何についてのものなのかを、フィールド名を説明することなく説明してくれる。


▼ The Thrift CompactProtocol encoding Figure 4-3
・semantically には BinaryProtocol と同じ。だが、よりサイズがコンパクトになる。
どのようにか
・フィールドタイプとタグ番号を、単一のバイトと、文字列の長さを表す int で表現できる。
・1337 という数値を、8バイトではなく2バイトにエンコードする。
どのようにか
各バイトの最初のビットをつかって、まだバイトが続くかどうかを支持する。
結果
- 64 ~ 63 までの数値は1バイトにエンコードされる。
-8192 ~ 8191 までの数値は 2バイトで表現される。数が大きくなれば、もっと バイトを必要とする。


■■■■■■■■■■■■■■■■■■■■■■■■■■ Protocol Buffers ■■■■■■■■■■■■■■■■■■■■■■■■■■
・CompactProtocol と似ている。
・CompactProtocol が 34バイトでエンコードするレコードを、33バイトでエンコードできる。



■■■■■■■■■■■■■■■■■■■■■■■■■■ フィールドの有無はエンコードに無関係
・スキーマによって、各フィールドが必須だったりオプションだったりするが、
そのことはフィールドがどのようにエンコードされるか、という観点においては何の違いもない
※ バイナリ側は、フィールドの要否を指定してない
・どこが違うかというと
フィールド必須、の場合フィールドが無いと ランタイムチェックで失敗する
 →バグのキャッチに有用


 ■■■■■■■■■■■■■■■■■■■■■■■■■■ Field tags and schema evolution
 ・スキーマはいずれ変更される運命にある。
 これを、「スキーマの進化」と呼ぼう。

▼ 前方後方互換性を担保しつつ、どうやってスキーマ変更に対処できるのだ？
・エンコードされたレコードというのは、エンコードされたフィールドを連結させただけのものなのだ。// 山田 吾郎 TBS 1997
・各フィールドは、タグ番号で同定できる。// 2 → TBS
・データタイプの注釈もある(e.g., string or integer)
・フィールドの値がセットされていなければ、エンコードされたレコードから取り除かれる、ただそれだけ。

つまり、わかっていただけるだろうか？
フィールドのタグは、エンコードされたデータの意味にとってクリティカルなのだ。

▼ タグが大事
・スキーマ内の、「フィールド名」は変更可能
(なぜなら、エンコードされたデータはフィールド名を参照しないから)
・フィールドの「タグ」は変更できない
(なぜなら、そんなことしたらすべてのエンコードされたデータが invalid になってしまう)

▼ スキーマに新規フィールドを追加することができる。
(ただし、各フィールドに、新しいタグ番号を付与する必要あり)

・古いコード(新規追加されたタグ番号を知らないような)が、新しいコードで書かれたデータを読もうと試みたとする
 →そこには、古いコードが認識できない新しいフィールド(新しいタグの)がいるとする
  →古いコードは、そのフィールドを無視する。ただそれだけ。

▼ データタイプ アノテーションの役割
 →パーサーが、何バイトスキップしたらよいか判断するのに利用する。
 →これによって、前方互換性が維持される。古いコードは新しいコードで書かれたレコードを読むことができる。
そうか、では、後方互換性はどうだ？
・各フィールドがユニークなタグ番号を保持している限り、
新しいコードは古いデータを読むことができる。
なぜならば、だ。
タグ番号はずっと同じ意味を持っているから。

▼ 新規フィールドを「required」にすることはできない
新規フィールドを追加したとする。
 →その時あなたは、そのフィールドを「required」とすることはできない。
なぜか
たとえば、あなたが新規フィールドを追加して、そのフィールドは必須だ、としたとする。
もし新しいコードが古いコードが書いたデータを読んだ場合、チェック時に失敗する。
 →だって、古いコードはその「新しいフィールド」を記述していないのだから。
ではどうするのか
・後方互換性を維持するためにも、スキーマの初期デプロイ後に追加したすべてのフィールドは、
オプションとする、または、デフォルト値を設定しておく

・フィールドを削除する場合、フィールドを追加する場合の前方互換性、後方互換性の関係がひっくり返った感じになる。
つまり、
オプションのフィールドに限り、削除することができる。
削除したタグ番号と同じ番号を使うことはできない。



■■■■■■■■■■■■■■■■■■■■■■■■■■ Datatypes and schema evolution
▼
では、フィールドのデータタイプを変えるのはどうなのだ？
--- 可能かもしれない
ドキュメントをチェックしてみるといい。
だが、そこにはリスクが有る。
データタイプを変えた値は、正確ではなくなる、または切り捨てられるというリスクが。

例)
３２ビット整数を６４ビット整数に変えたとする。
新規コードは古いコードで書かれたデータを読むことができる。
なぜならば
パーサーは不在のビットをゼロで埋めることができるから。
だがしかし
古いコードが新しいコードを読んだ場合、古いコードは、その値を保持するのに３２ビットを使い続けている。
で、もしデコードされた ６４ビットが３２ビットにフィットしなかったとしたら、その値は切り捨てられる。

▼ Protocol Buffers はリストという表現をせず、ただ繰り返しを行うだけ。だがそれがいい。
Protocol Buffers は、リストや配列データタイプをもたない。
代わりに、
フィールドのための a repeated marker というのが存在する
※ required and optional に次ぐ、第三のオプション
Figure 4-4 にあるように、
a repeated field のエンコードは、ただ同じフィールドタグがレコード上で複数回登場するだけ
これが、よいのだ。
オプション(single- valued)のフィールドを、繰り返し(multi-valued)フィールドに変更することが可能になるのだ。
・新コード
新コードは、古いデータのリストを、ゼロもしくは一つの要素とみなす(depending on whether the field was present)
古いコードは新しいデータを、リストの最後の要素としてみなす。

▼ Thrift にはリストデータ型がある。
・which is parameterized with the datatype of the list elements.
上記は、Protbuffのように、単一の値から複数の値へ、といった進化ができない。
しかし、
ネストしたリストをサポートしている、といったアドバンテージが有る。
