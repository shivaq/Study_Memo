■■■■■■■■■■■■■■■■■■■■■■■■■■ Column-Oriented Storage
・行が兆単位で、ファクトテーブルのデータがペタバイトもあったら、効率的クエリをどうするか、という問題がでてくる。
・ディメンションテーブルは、何百万行くらいで、ファクトテーブルより少ない。

▼ ファクトテーブルへのデータアクセス
・ファクトテーブルは列が百を超えてたりするが、クエリ時に一度にアクセスされるのは４，５列分くらい
※ "SELECT *" みたいなクエリは、分析時には滅多に行われない
例)
2013年に、フルーツを買った人DB
行が大量にある
アクセスしたいのは、fact_sales テーブルの date_key, product_sk, and quantity のみ
-------------------------------------------------
SELECT
  dim_date.weekday, dim_product.category,
SUM(fact_sales.quantity) AS quantity_sold FROM fact_sales
JOIN dim_date ON fact_sales.date_key = dim_date.date_key
JOIN dim_product ON fact_sales.product_sk = dim_product.product_sk
WHERE
dim_date.year = 2013 AND
dim_product.category IN ('Fresh fruit', 'Candy')
GROUP BY
dim_date.weekday, dim_product.category;
-------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■ 大量ファクトテーブルの効率的クエリ方法とは？
・殆どのOLTPDBでは、ストレージは行指向でレイアウトされている。
・テーブルの任意の一行のすべての値は、並べて格納されている

▼ ドキュメントDBの場合
ドキュメントDBも似たようなもので、ドキュメント全体が一つの連続した一連のバイトとして格納されている。
・クエリをする場合、下記に対するインデックスを使ったりする
fact_sales.date_key and/or fact_sales.product_sk
 →特定の日付のすべてのセールス、または特定の製品のすべてのセールス、といった情報を、どう探したらいいかを ストレージエンジンに伝える。
 
▼ インデックスを使っていても、クエリコストに無駄が多い
・すべての行をディスクからメモリにロードする ※属性は100以上あったりする
 →それらをパースする
  →条件に合致しないものどもをフィルターアウトする
   →時間がかかる

■■■■■■■■■■■■■■■■■■■■■■■■■■ column-oriented storage
・一つの行のすべての値を一緒に格納しない
かわりに
・各列のすべての値を一緒に格納する
・各列が隔離されたファイルだったならば
 →クエリに使う行だけを読んで、パースすればよい →無駄が省ける

・コラム指向ストレージは、RDBに多い
※ Parquet は、ドキュメントデータモデルをサポートするコラム指向ストレージ

・コラム指向ストレージレイアウトは、各コラムファイルが、同じ順番で行を並べている、という前提条件が必要
 →行を再組み立てする時、各コラムを寄せ集めた、23番めのエントリー、といった取得が可能
