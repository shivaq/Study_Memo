■■■■■■■■■■■■■■■■■■■■■■■■■■ Sorted String Table, or SSTable
ソートされた文字列のテーブル

・キーバリューペアを、キーでソートすることが要求される
・各キーは各マージされたセグメントファイル内で、一度しか現れない
※ Compaction 処理によってすでに保証されている
・hash index と比べて、log segments に関連して大きなアドバンテージが有る

1. セグメントのマージがシンプルで効率的
・ファイルが利用可能メモリより大きくても大丈夫
・入力ファイルを端から端まで読む
 →各ファイル内の、最初のキーを見る
  →ソート順の一番若いキーを、アウトプットファイルにコピーする
   →これを繰り返す
    →ソート済みの新しいマージセグメントファイルが生成される


※ 同じキーがいろんなセグメント内にいた場合はどうなる？
ポイント：各セグメントは、ある程度の時間、DBに書き込まれているすべての値を含んでいる
 →インプットセグメントのすべての値は、他のセグメントのすべての値よりも直近のもの、ということになる。
 よって、複数のセグメントが同じキーを持っていたとしても、直近のセグメントの値を保持して、古いセグメント内の値を捨てることができる。


2. キーをファイルから探すために、すべてのキーをメモリに保持しなくてもいい。
・handiwork というキーを探したいとする。
 →そのキーの、セグメントファイル内でのオフセットはわからない。
  →でも handbag and handsom のオフセットはわかっている
   →キーはソートされているから、ほしいキーが知ってるオフセットのどれとどれとの間にあるのか、ということがわかる。
    →結果、すべてのキーのオフセットをメモリ内に保持していなくても、ある程度当たりをつけて検索できる



3.
読み込みリクエスト時は、リクエストされた範囲の、複数のキーバリューペアがスキャンされる
 →だったら →それらペア自体をグループ化して、ディスク書き込み前に圧縮する、というやり方もある。
 →圧縮されたブロックの最初の値？かなんか？が、メモリ内インデックスのエントリーになる
  →圧縮の結果：ディスク容量だけでなく、I/Oも削減できる

■■■■■■■■■■■■■■■■■■■■■■■■■■ SSTable の構築とメンテナンス
・書き込みが来た
 →メモリ内に、ツリーデータ structure を使って追加
 ※ memtable: メモリ内ツリーのことをこう読んだりする

・memtable のサイズがしきい値を超えた
 →ディスクに、SSTable ファイルとして出力 ※ この間 書き込みは新規 memtable になされ続ける
 ※ ツリー構造の時点で、キーバリューペアはソート済み
 ※ 新しい SSTable ファイルは、DB内の最新セグメントということになる

・読み込みをする順番
 →memtable からキーを探す
  →ディスク上の直近セグメントから探す
   →次のセグメントを探す

・定期的にマージとCompactionをバックグラウンドで行って、上書きしたまたは削除した値を捨てる

■■■■■■■■■■■■■■■■■■■■■■■■■■ SSTable の課題
DBクラッシュする
 →直近の書き込みが欠損する(memtable にはあるが、ディスクには書き込まれていない)
回避策：
すべての書き込みが即appendされる別のログをディスクに保持
 →ソートされてなくていい。memtable をリストアするためだけのための存在だから。
  →memtable が SSTable に書き込まれると、都度 対応するログが捨てられる



■■■■■■■■■■■■■■■■■■■■■■■■■■ Log-Structured Merge-Tree (or LSM-Tree)
・バックグラウンドでマージされた、SSTable のカスケード構造を保持する。

・データはソートされて格納されている。
 →範囲クエリが効率的

・ディスク書き込みがシークエンシャル
 →書き込みスループットがめちゃ早い

・LSM-tree algorithm は、クエリ時にキーがないと遅くなる可能性がある。
 →memtable をチェックして、セグメントを一番古いものまでチェックしていく。
上記最適化するために：Bloom フィルタを使う

▼ Bloom フィルタ
あるセットのコンテンツの近似を出す、メモリに最適化したデータ構造。
キーがDB内にあるかどうかがわかる。




▼ SSTable のマージとCompactionのタイミングを判断するストラテジ
▼ size-tiered
HBase Cassandra が採用
より新しい、より小さい SSTable は、より古い、またはより新しい SSTable に連続する形でマージされる

▼ leveled compaction
LevelDB and RocksDB Cassandra が採用
キーの範囲によって、より小さい SSTable に分割される
 →古いデータは別のレベルに移動される
 結果：Compaction が incremental に実施され、ディスクスペース占有が少なくてすむ
