■■■■■■■■■■■■■■■■■■■■■■■■■■ Message-Passing Dataflow
▼ asynchronous message-passing systems
RPC と DB の間のような位置づけ？

ここはRPCに似ている
 →クライアントのリクエスト(AKA メッセージ)が他のプロセスに、低いレイテンシーで送られる

ここはDatabase に似ている
 →メッセージはネットワーク接続を使って直接送られるわけではない。
 メッセージブローカー(or メッセージキュー or メッセージオリエンテッドミドルウェア)と呼ばれる仲介者を経由して送られる。
 ※ そして、メッセージはキューに一時的に格納される。

▼ メッセージブローカーが、RPCに優る点
・受け手が unavailable or overloaded な場合のバッファーとして機能して、システムの信頼性を改善する。
・クラッシュしたプロセスにメッセージを再送することで、メッセージの欠損を防ぐ
・送り手が、受け手のIPアドレス、ポート番号を知っておく必要がない。
※ クラウドでデプロイする時に便利。VMは作られたり削除されたりが起きるから。
・一つのメッセージを、複数の受け手に送ることが可能
・論理的に送り手と受け手が切り離される。
※ 送りてはメッセージを発行するだけ。誰がそれを consume するかは関知しない

▼ メッセージの送り手は返信を受けられない
・message-passing communication はたいてい片道
・メッセージに対する返信は期待できない
・プロセスが返信を送ることはできる。
しかし
それは通常別のチャネルで行われる。
このコミュニケーションパターンが、asynchronous と呼ばれる。

▼ asynchronous パターン
・送り手はメッセージが配信されることを待たない。ただ送る。その後は関知しない。

■■■■■■■■■■■■■■■■■■■■■■■■■■ Message brokers
▼ 商用
TIBCO, IBM WebSphere, and webMethods

▼ open source
RabbitMQ, ActiveMQ, HornetQ, NATS, and Apache Kafka


▼ message brokers の一般的な使われ方
・あるプロセスがメッセージをキューやトピックに送る
 →そのキューやトピックの consumer や subscriber にメッセージが送られることを、ブローカーが保証する。
・あるトピックには、複数の producers と consumers が存在しうる

▼ 疑似双方向データフロー
・トピックは一方通行のデータフローのみを提供する
・consumer は他のトピックにメッセージを発行できる
 →メッセージのチェーンができる
・さらに、consumer はキューを返すことができる。
 →そして、オリジナルメッセージの送り手がそのキューをサブスクライブできる
※ RPC のように、リクエスト/レスポンスデータフローが出来上がる

・メッセージブローカーはどんなデータモデルを使うか強制しない
 →メッセージはただの一連の bytes // メタデータつき
  →なので、どんなエンコーディングフォーマットも使える

・エンコーディング に 前方後方互換性があると、
すごく柔軟に扱える
publishers と consumers を個別に変えることができるし、
それぞれすきな順番でデプロイできる

▼ consumer がメッセージを別のトピックに再発行するときの注意
知らないフィールドが合った時、
DBの場合の下記問題が発生しないよう気をつける必要がある。
// DBの値を アプリのOBJ にデコードする
//  →そのモデルを再度エンコードする
//   →その時、未知のフィールドが翻訳プロセス時にロストする可能性もある。

■■■■■■■■■■■■■■■■■■■■■■■■■■ Distributed actor frameworks
▼ The actor model
シングルプロセスの並行性のためのプログラミングモデル。
・スレッド(そしてrace conditions, locking, and deadlock といった関連する問題)と直接やり取りせず、
ロジックがアクター内にカプセル化されている。

各アクターは、
あるクライアントまたはエンティティを表しており、
ローカルな状態を持つ。// そしてその状態は他のアクターと共有されない
・他のアクターとの交信は、非同期メッセージのやりとりで行われる。

▼ メッセージ配信は保証されない
特定のエラーシナリオでは、メッセージはロストする。
各アクターは一度に一つのメッセージを処理するだけ
よって、
スレッドについて心配する必要はない
各アクターはフレームワークに依存することなくスケジュールすることができる。

・分散アクターフレームワークでは、このプログラミングモデルは複数のノード間でアプリケーションをスケールするのに使われる。

▼ Location transparency
同じメッセージパッシングメカニズムが、送り手と受け手とが同じノードにいようが、別のノードにいようが使われる。
別のノードにいる場合は、メッセージは透過的にエンコードされ →ネットワークを越え、相手ノードでデコードされる。
・Location transparency は、RPC よりも アクターモデルでより良く機能する。
なぜならば
アクターモデルは、たとえシングルプロセスないであってもメッセージがロストする可能性を考慮しているから。

アクターモデルを使うと、
ネットワーク越しのレイテンシーは同じプロセス内と比べて高くなるが、
基本的にはローカルとリモートとのアクセスでの違いはあまりない。

アクターモデルは、
メッセージブローカーと、アクタープログラミングモデルとを
一つのフレームワークに統合したもの
しかし、
アクターモデルを使ったアプリだとしても、
ローリングアップグレードを行う場合は前方後方互換性を気にしなければならない。


■■■■■■■■■■■■■■■■■■■■■■■■■■ みっつの分配アクターフレームワークと、そのメッセージエンコーディング方法
▼ Akka
Java の組み込みシリアライゼーションをデフォルトで使用する。
そしてそれは前方後方互換性を提供していない。
しかし
それの代わりに Protocol Buffers を使うこともできるので、
ローリングアップグレードもできるようになる。

▼ Orleans
デフォルトのカスタムデータエンコーディングフォーマットは、ローリングアップグレードをサポートしていない。
新バージョンのアプリをデプロイする場合は、
新しいクラスタをセットアップして
 →古いクラスタから新しいクラスタにトラフィックを移動して
 →古いクラスタをシャットダウンする。
Akka と同様、カスタムシリアライゼーションプラグインが使用可能

▼ Erlang OTP
レコードスキーマの変更がびっくりするくらい難しい。
※ 高可用性のためにデザインされたフィーチャーをたくさん有しているけれど
ローリングアップグレードは可能だが、慎重に計画する必要がある。
・new maps datatype によって事態が改善されるといいですね。
