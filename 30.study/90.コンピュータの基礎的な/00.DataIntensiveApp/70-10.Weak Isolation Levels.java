■■■■■■■■■■■■■■■■■■■■■■■■■■ Weak Isolation Levels
もし、2つのトランザクションが同じデータをたっちしないのであれば、
そいつらは安全にパラレル実行できる。
なぜならば、
互いに依存関係にないから。

▼ Concurrency が問題になる場合
競合状態が問題になるのは、
あるトランザクションが他のトランザクションが同時に書き込んでいるデータを読み込もうとしたとき
または
2つのトランザクションが同じデータを同時に変更しようとしたとき。

Concurrency バグ はテストで発見することが難しい。
なぜならば、
そういったバグはタイミングが悪かった時にのみ引き起こされるから。
そういうタイミングはめったに起きない。
で、通常リプロデュースすることが難しい。
さらに、
大きなアプリケーションで、どのコードがDBにアクセスするか、知る必要がない場合は
特に難しい。

複数のユーザーが同時に存在するようなアプリは、データのあらゆる部分が、いつでも予期せぬ変更がなされうるため、
まあ、すごく難しい。

そんなわけで、DBは長い間 トランザクションの Isolation によって、Concurrency の問題をアプリ開発者から見えなくしようとしてきた。
理論上は、
isolation は Concurrency が起きてないかのように見せることで、開発者に楽をさせることができる。
serializable isolation が意味するのは、トランザクションが serially に行われた(のと同様の)状態をDBが保証するということ。
※ 一度に一つずつ、Concurrency など存在しないかのように。

だが現実は、
Isolation はそんなシンプルじゃない。
Serializable isolation にはパフォーマンスコストがあるし、多くのDBはそのコストを払いたくない。
よって、
多くのシステムは weaker levels of isolation を使うことが普通だ。
いくつかの Concurrency には対処するが、全部ではない。

この手の Isolation は理解するのが難しいし、わかりにくいバグを起こすかもしれない。
だが実際使われているんだからしょうがない。

weak transaction isolation を原因とした Concurrency バグは、多くの金銭的損失を起こし、
財務監査による調査を引き起こし、顧客データの損害も引き起こしてきた。

上記のような問題に対するよくある反応は、
“Use an ACID database if you’re handling financial data!”
といったものだが、ポイントがずれている。
“ACID” であると考えられているたくさんの人気のRDBシステムでさえ、weak isolation を使っている。
よって、
いわゆる ACID を使えばこれらバグの発生を防ぐことができる、というのは間違いだ。

盲目的にツールに頼るのではなく、
存在する Concurrency 問題の理解を深め、それらをどう防ぐことができるか、を知る必要がある。
そうすることで、
そういったツールを上手く使いつつ、そこらへんちゃんとしたアプリを構築できる
