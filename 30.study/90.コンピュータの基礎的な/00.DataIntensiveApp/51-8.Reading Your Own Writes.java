■■■■■■■■■■■■■■■■■■■■■■■■■■ Reading Your Own Writes
俺が書いた書き込みを俺が読むんやで

▼ ユーザーがサブミットしたデータをその後表示させるという方法
多くのアプリは、ユーザーがサブミットしたデータを、そのあとに表示させている。
// それはユーザーのDBのレコードかも知れないし、スレッドのコメントかもしれない。
新しいデータがサブミットされた時
それはリーダーに送られる
しかし
ユーザーがデータを見る時
それはフォロワーから読み込まれる
この、サブミット後表示される方法が適切なのは、
データは頻繁に見られるけど、書き込みはそうでもない、といったケースだ。

▼ 非同期だと、書き込みがロストしたように見える
もしユーザーが書いた直後にデータを見ようとした場合
新しいデータはレプリカに未到達かも知れない
ユーザーは
サブミットしたデータがロストしたようにみえるだろう。


▼ read-after-write consistency AKA read-your-writes consistency
・この方法が保証することは、
ユーザーがページをリロードした場合、彼等自身がサブミットした更新が常に見ることができる、ということだ
しかしそれは、
他のユーザーが同じくその更新が見られることを保証しない。
他のユーザーはもう少しあとにしか見られないかも知れない
しかしながら、
ユーザーは、自身の入力が正しく保存されたのだ、という手応えを得られる。


▼ read-after-write consistency  の実装方法
1. ユーザーが書き込んだものを読むときは、リーダーから読み込む
それ以外の場合は、フォロワーから読み込む
これを実現するためには
クエリをすることなく、それが書き込みされたものなのかどうなのかを知る方法が必要。

例えば
SNS のユーザープロファイルは、通常そのユーザーのみが編集でき、他の人はできない。
この場合は簡単
ユーザー自身のプロファイルは、リーダーから読む。
他のユーザーのプロファイルは、フォロワーから読む

1. アプリの殆どがユーザーによって編集できる場合
ユーザーが書いたものはリーダーから読む、という方法は単純にはうまくいかない。
じゃあどうするか
最終更新時間を追跡する。
最終更新から1分間は、全ての読み込みをリーダーから行う。
レプリケーション遅延もモニターし、
リーダーから1分以上遅延しているフォロワーに対しては、クエリを行わないようにする

1.
クライアントが自身の直近の書き込みのタイムスタンプを保持できるようにする。
システムは、そのユーザーが更新した内容に関しては、
上記タイムスタンプの時間までのものは、
全てレプリカから読むことができることを保証する。
もし、
レプリカが上記条件を満たすだけの最新の状態ではない場合、
他のレプリカによって読み込みが handle するか、
レプリカが追いつくまでクエリ返答を待つ。
で、
ここでいうタイムスタンプは、ロジカルタイムスタンプだったりする。
※ ログのシークエンス番号など、書き込みの順番を示すもの
または、
システムの時計だったりする。この場合、時刻同期がクリティカルになる。

1.
レプリカが、複数のデータセンターに分散されていた場合 // ユーザーの地理的に近い場所でサーブするため、または可用性のため
追加の複雑さがある。
リーダーが対応しなければならないあらゆるリクエストは、
リーダーがいるデータセンターを必ず経由しなければならない。


▼ 同じユーザーが異なるデバイスを使う場合の consistency
// PCのブラウザとモバイルのアプリなど
例
クロスデバイスで、read-after-write consistency を実現したい場合
ユーザーがあるデバイスで情報を書き込む
そして、その情報を他のデバイスで読み込む
その時目にするのは、
入れたばかりの情報であるべき
それを実現するために：
・ユーザーの直近のアップデートを記憶するためのタイムスタンプは、中央で管理せねばならない。
なぜなら、あるデバイスは他のデバイスがどんな更新をしたか知りえないから。
・レプリカが複数のDCにまたがっている場合、
異なるデバイスからのアクセスが同じDCにルートされるかはわからない。
例
デスクトップコンピュータが有線ブロードバンドを使っており、モバイルはセルラー網を使っている場合、
ネットワークルートは完全に異なるかもしれない
そして、
もし、リーダーから読み込むアプローチを取るならば、。
全てのデバイスからのリクエストは同じDCにルートしなければならない可能性がある。
