▼ HW 不良 への対策
・冗長性をもたせる ※ かつてはこれで十分だった
・少ない数のアプリであり、かつ高可用性が絶対必用なアプリには、冗長性が必要
・最近のアプリは、データボリュームとアプリの処理能力の要求が高まってきている。
結果、たくさんのマシンが使われ始めている。
結果、HW 不良のレートが上がってきている。
※ そして、AWS などは予告なしにインスタンスが使えない状態になったりする
・最近は、全マシンがだめになっても耐えられるシステムへの移行が始まっている。
どのように：耐障害性テクニックを使ったソフトウェア



▼ ヒューマンエラー対策
・エラーが起こる機会をへらす。
抽象化をすすめる。APIを使う。
・管理者用インターフェイスを使って、間違いを起こりにくくする →結局めんどくさくて、管理者IFはワークアラウンドされることになる。バランスが大事
・failure を生じさせる可能性がある場所から、人間がよく間違えを起こす部分をデカップルする。※ sandbox環境
・すべてのレベルでテストを行う。ユニットテストから統合テスト、手動テストまで。
・自動テストはコーナーケースをカバーするのに特に有用
・ヒューマンエラーからの素早い回復ができるようにしておく。
failure のダメージを最小化する。
たとえば
・設定変更のロールバックをすばやくできるようにする
・新しいコードは少しずつロールアウトして、バグが発生した際の影響yフーざーを小さくする
・データの再計算を行うツールを用意する ※ その前の計算が正しくないと判明したときのため




■■■■■■■■■■■■■■■■■■■■■■■■■■ load parameters
・アーキテクチャによって、適したパラメータは異なる
例) Webサーバに対する request/sec
・DB の read/writes 比率
・チャットルームでの同時アクティブユーザー数
・キャッシュのヒットレート


■■■■■■■■■■■■■■■■■■■■■■■■■■ ユーザーページ更新方法
▼ 方法1
・ツイートをする
 →グローバルなツイートの集合に新規ツイートを挿入する
・ユーザーがホームタイムラインをリクエストする
 →ユーザーがフォローしている人々を照会する
 →フォロー対象のすべてのツイートを探す
 →それらツイートを時間でソート
 →マージ

SELECT tweets.*, users.* FROM tweets
JOIN users ON tweets.sender_id = users.id
JOIN follows ON follows.followee_id = users.id
WHERE follows.follower_id = current_user

▼ 方法2
・各ユーザーのホームタイムラインのキャッシュを維持する ※ ツイートのメールボックスのようなイメージ
・あるユーザーがツイートする
 →そのユーザーをフォローしているすべてのユーザーを検索する
 →その新規ツイートを各ユーザーのホームタイムラインキャッシュに挿入する
結果、ホームタイムラインへのリクエストは cheap になる。なぜなら、その結果は事前に計算されているから。



▼ ハイブリッドな方法
・セレブリティのユーザーは、fan-out する可能性がある
・セレブリティのツイートに関しては、その他のユーザーのツイートとは別に取得して、方法1のように、ユーザーたちのホームタイムラインにマージする



■■■■■■■■■■■■■■■■■■■■■■■■■■
▼ Hadoop などのバッチ処理システムでのパフォーマンスについての考え方
・スループット(処理できるプロセスの数/sec)を考慮
・あるサイズのデータセットに対するジョブにかかるトータル時間を考慮


・アーリーステージのスタートアップや、うまくいくかどうかわからない製品は、将来訪れると予想している仮の負荷に耐えれるようスケールすることよりも、
トライアンドエラーをすばやく回すことがより重要。



■■■■■■■■■■■■■■■■■■■■■■■■■■ Evolvability
▼
データシステムの修正の容易さや、要件変更への適応の容易さは、シンプルさと抽象化とリンクしている。
シンプルでわかり易いシステムは、複雑なものより修正が容易である。


■■■■■■■■■■■■■■■■■■■■■■■■■■ Maintainability
ソフトウェアでお金がかかるのは、初期の開発費ではなく、それに続く保守の方だ。
・バグを治す
・システムが操作可能な状態に維持する
・失敗を調査する
・新しいプラットフォームにアダプトする
・新しいユースケースに適応させる
・テクニカル debt の支払いをする
・新規 feature を追加する

■■■■■■■■■■■■■■■■■■■■■■■■■■ Operability
・異なるシステム同士がどう影響し合うか、Keeping tabs する。そうすることで、問題のある変更を事前に避ける事ができる。

・ドキュメントをしっかりする。わかりやすいオペレーションモデルを使う
If I do X, Y will happen.
・デフォルトの振る舞いを整備し、かつ、アドミンには必要に応じてデフォルトの振る舞いを上書きする自由を与える
・必要のうじて自己治癒ができるようにする。しかし、アドミンには必要に応じてシステムに対し手動コントロールができるようにする
・予測される振る舞いを示し、 surprise を最小化する


■■■■■■■■■■■■■■■■■■■■■■■■■■ 複雑さを管理する
・変更時にバグが混入するリスクが高まる
隠された仮定、意図せぬ結果、予期せぬ相互作用などなどが見過ごされやすくなる

■■■■■■■■■■■■■■■■■■■■■■■■■■ 複雑さの症状
・用語や名前の規則の一貫性のなさ
・パフォーマンスの問題を解決することを目的にしたハック
・どこかの問題をワークアラウンドするための特別な処置

■■■■■■■■■■■■■■■■■■■■■■■■■■ シンプルにするために
・複雑さを減らすと、保守性が上がる。よって、シンプルさはシステム構築におけるキーのうちの一つとなる。

■■■■■■■■■■■■■■■■■■■■■■■■■■ 抽象化が複雑さを取り除く
・よい抽象化は実装時のディテールを覆い隠す。
・良い抽象化は、異なるアプリでの利用を可能にする
・高品質なソフトウェアになる。抽象化されたコンポーネントの品質改善は、それを使うすべてのアプリの利益となる。





■■■■■■■■■■■■■■■■■■■■■■■■■■ データモデルのレイヤー化
ほとんどのアプリケーションは、あるデータモデルを他のデータモデルの上に置くようなレイヤー化をして構築されている。
各レイヤーにおけるキーとなる問い：そのレイヤーは、下位のレイヤーでどのように表現されているか？

1.現実世界のものども(人々、組織、モノ、行動、マネーフロー、センサー)を、OBJ というかたち、またはデータ構造というかたちでモデル化する。
それら構造はしばしばあなたのアプリ固有のものである。

2.データストラクチャを格納したい時、それを下記形式で表現する
・JSON、XML
・RDB のテーブル
・グラフモデル

3.DBソフトウェアを構築したエンジニアが、JSONやテーブル、グラフデータを、
メモリ、ディスク、ネットワーク上で bytes として表現する方法を決める。
その表現によって、データをクエリ、検索、操作、処理する方法が異なってくる。

4.HWや エンジニアがbytesを電気、光、磁気といった形でどう表現するかを決める。

X.複雑なアプリケーションは、もっと中間レベルのものがあるかもしれない
APIの上に構築されたAPIなど。しかし、基本となるアイデアは同じ。
各レイヤーは下位のレイヤーの複雑さを隠して、スッキリしたデータモデルを提供する。
抽象化の結果、DBベンダの開発者や、アプリの開発者が、効率よく協働できる。

■■■■■■■■■■■■■■■■■■■■■■■■■■ Document Model
▼ ストレージローカリティが向いていないケース
・ドキュメントの一部にだけアクセスしたいときでも、ドキュメント全体をロードする必要がある。
・ドキュメント更新時には、ドキュメント全体を rewritten する必要がある。

▼ ドキュメントは小さく管理せよ
ドキュメントは小さくしておくことが推奨されているし、ドキュメントのサイズが大きくなるような書き込みは回避するよう推奨されている。

■■■■■■■■■■■■■■■■■■■■■■■■■■ ドキュメント オリエンテッド データベース
・ドキュメントモデルは、カタログ、ユーザープロファイル、コンテンツ管理システムなど、各ドキュメント固有のもの
・時間の経過とともに進化するユースケースでうまく機能
・KVSとDODとの違いは、key value store はDBから不透明に見えるが、DODは、ドキュメントの内部構造のメタデータを、DBエンジンが最適化のために使う



▼ Retrieval
DODのもう一つの特徴として、データの取得方法に、キーによる取得だけでなく、
API やクエリ言語を提供することで、ユーザーがコンテンツやメタデータに基づいてドキュメントを取得できるようにしている

例)
あるフィールドの値が一致するすべてのドキュメントを取得するようクエリする。









▼ SQL は Declerative なクエリ言語だ。
ほしいデータのパターンを伝えるだけ。どんな条件の結果がほしくて、どういうふうにトランスフォームしてほしいか(ソート、グループ、aggregate)
でも、どのようにそのゴールを達成するかは、DBシステムのクエリオプティマイザーにまかせている。
-------------------------------------------------
SELECT * FROM animals WHERE family = 'Sharks';
-------------------------------------------------
・簡潔
・並列処理に向いてる
