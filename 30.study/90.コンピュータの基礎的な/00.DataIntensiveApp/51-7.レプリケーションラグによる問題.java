■■■■■■■■■■■■■■■■■■■■■■■■■■ Problems with Replication Lag


▼ レプリケーションがしたいのは、fault tolerance だけが理由じゃないから。
・scalability (processing more requests than a single machine can handle)
・atency (placing replicas geographically closer to users)


▼ リーダーベースのレプリケーションに必要なこと
・全ての書き込みは単一のノードに対してなされる
・読み込みクエリはどのレプリカになされても良い

・書き込みは少なくて、ほとんど読み込みのワークロードにとっては魅力的な方法// Web にはよくあるパターン
 →フォロワーをたくさん作って、読み込みリクエストをフォロワー間に分散させる
 →リーダーの負荷がなくなり、地理的に近いレプリカに読み込みリクエストができる

▼ しかしそうはうまくいかない
リードスケーリングアーキテクチャでは、
フォロワーを追加するだけで
リードオンリーリクエストをさばくキャパシティが増やせる
しかし
現実的にはこれは非同期レプリケーションでのみ、できること。
もしもだ、
全てのフォロワーに対し、同期でレプリケートする場合
一つのノードの不良やネットワークの機能停止が
システム全体の書き込み不能を引き起こす。
さらに、
ノードが増えれば増えるほど、そのいずれかがダウンする可能性は高くなり、
信頼性は低くなる。

▼ "eventual consistency"
・アプリが非同期フォロワーから読み込んだ場合、
そしてフォロワーへの更新が遅れている場合、
読み込んだ情報は古い情報かもしれない。

この inconsistency は一時的なものである。
DBへの書き込みを一旦止めて、少し待てば、
フォロワーも追いついて、リーダーとおなじになる。
そしてこれは "eventual consistency" と呼ばれる。

・どれくらい eventually なのか。
通常なら、遅延はリーダーへの書き込みと、フォロワーへの反映の間のレプリケーションラグであり、
一秒以下だったり、気づくこともなかったりする
しかし
システムの負荷がギリギリだったり、ネットワークに障害が起きてたりしたら？
遅延は数秒から数分にまで膨れ上がりかねない

遅延が大きくなれば、それはもう理論上の課題ではなく、アプリケーションのリアルな課題になってくる
