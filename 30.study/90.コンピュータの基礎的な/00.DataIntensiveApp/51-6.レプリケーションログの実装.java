■■■■■■■■■■■■■■■■■■■■■■■■■■ Implementation of Replication Logs
・各種レプリケーションメソッドの紹介

■■■■■■■■■■■■■■■■■■■■■■■■■■ Statement-based replication
// 誰が使っているか
※ MySQL before version 5.1 では使われていた
 →現在は、MySQL は nondeterminism があるステートメントの場合は row- based replication にスイッチした。

・リーダーは実行した全ての書き込みリクエストログをフォロワーに送る

▼ RDBの場合
全ての INSERT, UPDATE, or DELETE statement はフォロワーに転送される
 →各フォロワーはそのSQLステートメントをパースして、実行する
 ※ あたかもクライアントから直接受信したステートメントであるかのように。

▼ 注意点をいくつか
・NOW() とか呼び出すと、レプリカごとに違う結果が。。。
nondeterministic function を呼び出すステートメントは、各レプリカで異なる値を生成するかもしれない
※ NOW()、time or RAND()

・同じ順番で実行しないと困る
ステートメントが オートインクリメントの列を使う場合
または
DB上の既存のデータに依存する場合
(e.g., UPDATE ... WHERE <some condition>)
各レプリカで、正確に同じ順番で実行されなければならない。
さもないと、
レプリカごとに異なる結果となる
This can be limiting 複数の並行実行トランザクションがある場合に。


• side effects があるステートメントは、各レプリカで異なるサイドエフェクトが発生する可能性がある
(e.g., triggers, stored procedures, user-defined functions)
それを避けるために
サイドエフェクトは absolutely deterministic である必要がある。

・サイドエフェクトを回避するアイデア
リーダーが 、ステートメントがログに出力された段階で、
"nondeterministic function calls" を固定値に置換して返す。
結果、
フォロワーは同じ値を受け取る
しかしながら
エッジケースがたくさんある。


■■■■■■■■■■■■■■■■■■■■■■■■■■ Write-ahead log (WAL) shipping
// 誰が使っているか
PostgreSQL and Oracle, among others

・log-structured storage engine の場合、// “SSTables and LSM-Trees”
Log segments は コンパクションされて、背後で GC される、

・B-tree の場合、
各修正は、まず"write-ahead log"に書き込まれる
その後、
個々のディスクブロックを上書きする。
そうすることで、もしクラッシュしたあとでも
インデックスは一貫した状態で復旧できる

▼ "an append-only sequence of bytes"
いずれの場合も
ログはDBへの全ての書き込みを含んだ "an append-only sequence of bytes"である。
上記ログは、
他のノードにレプリカを構築する用途にも使うことができる。
リーダーは、
ログをディスクに書き込むのに加えて
ネットワーク越しにそのログをフォロワーに送る。

・フォロワーが上記ログを処理する時
その時
リーダのそれと、全く同じデータ構造のコピーが構築される

▼ Write-ahead log (WAL) shipping の欠点
ログはデータを a very low level で表現する。
どういうことか
WAL は、どのディスクブロックのどのバイトが変更されたか、といった詳細を含んでいる。
そのため、
レプリケーションがストレージエンジンと密結合になる
もし
DBがストレージフォーマットを別のバージョンに変えようとしたら
リーダーとフォロワーとの間で、異なるバージョンのDBソフトウェアを使うことは通常不可能

▼ 上記問題がなければ、ダウンタイム無しでバージョン変更できるのに
・もしレプリケーションプロトコルが、下記ができる場合
フォロワーが、リーダーより新しいソフトウェアバージョンを扱えるようにする
その場合、
まずフォロワーたちをアップグレードする
 →次に、フォロワーのうちの一つを新リーダーに昇格させるための手動フェイルオーバーを行う
  →結果、DB ソフトウェアのゼロダウンタイムアップグレードができる
しかし、WAL にはできない
結果、DB バージョンアップにはダウンタイムが発生する

■■■■■■■■■■■■■■■■■■■■■■■■■■ Logical (row-based) log replication
// 誰が使ってる？
MySQL’s binlog // row-based replication を使うように設定されている場合

▼ "a logical log" と呼ばれるレプリケーションログ
・ストレージエンジンの物理的データ表現と判別するためにこう呼ばれる

・レプリケーションとストレージエンジンとで、異なるログフォーマットを使う
 →ストレージエンジンのとレプリケーションログとが疎結合になる

▼ RDB のロジカルログは、
(通常は)レコードのシークエンス
(一つの行レベルの粒度で)DBのテーブルへの書き込みを表現
・挿入された行の場合：ログはすべての列の新しい値を含む
・削除された行の場合：ログは対象の行を同定するのに十分な情報を含む
通常 Primary Key
テーブルにPKがない場合
すべての行の古い値全部をログ
・更新された行の場合：
1. ログは対象の行を同定するに十分な情報を含む
2. ログはすべての行の新しい値を含む// または、少なくとも変更がなされたすべての値

・複数の行を変更したトランザクションは
ログレコードも複数生成する
加えて、
そのトランザクションがコミットされたことを示すレコードも。

▼ ロジカルログレプリケーションの利点
・後方互換性が容易
リーダーとフォロワーとが異なるバージョンを扱えるし、異なるストレージエンジンすら扱うことが可能

・"change data capture"と呼ばれる利点
外部のアプリがパースすることが容易
DBのコンテンツを外部のシステムに送る場合、// データウェアハウス がオフライン分析に使うとか
カスタムインデックスとキャッシュを構築する場合

■■■■■■■■■■■■■■■■■■■■■■■■■■ Trigger-based replication
▼ アプリケーションレイヤーを巻き込んで行うレプリケーション
・その他のレプリケーションは、DBシステムによって実装されており、
アプリケーションのコードは関わっていない。
そして、それは望ましいことである。

だがしかし

より柔軟な方法がほしいなら、アプリケーションレイヤーを使う必要がある
例えば
データの一部だけをレプリケートしたい場合
別の種類のデータベースにレプリケートしたい場合
コンフリクトを解決するロジックが必要な場合

▼ いくつか方法がある
・Oracle GoldenGate
DB のログを読むことで、アプリケーションへのデータ変更が可能

・triggers and stored procedures
多くのRDB で利用可能な機能

▼ triggers and stored procedures
・自動実行されるカスタマイズしたアプリのコードを、トリガーに登録する
DBシステムでデータ変更が発生した時に、トリガーが発動する

▼ 別のシステムが読めるように"データの変更"を翻訳
変更をトリガーに、その変更を外部のプロセスが読むことができる、別のテーブルにログ出力する
 →外部のプロセスが、アプリロジックを適用して、データの変更を別のシステムにレプリケートする

▼ これができるのは誰だ
Databus for Oracle
Bucardo for Postgres

▼ 欠点
他のレプリケーションメソッドよりオーバーヘッドが大きい
バグや制約が入り込みやすい
しかし、それでも、
柔軟性がほしいときはある
