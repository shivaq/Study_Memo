■■■■■■■■■■■■■■■■■■■■■■■■■■ Strategies for Rebalancing
ノードにパーティションを割り当てる方法はいくつかある。

■■■■■■■■■■■■■■■■■■■■■■■■■■ How not to do it: hash mod N
キーのハッシュでパーティショニングするとき、
予測されるハッシュを範囲ごとに分割して、
各範囲をパーティションにアサインするのがベストである。
例)
0 ≤ hash(key) < b0
の場合、パーティション0

b0 ≤ hash(key) < b1
の場合、パーティション1

・分割アサインに mod を使うというアイデアを検証
hash(key) mod 10
 →0 ~ 9 の値を返す// ハッシュを 10進数にした場合、hash mod 10 は 1桁の値となる

ノードが10あったならば、0 ~ 9 の値がかえされたら各キーをノードに割り当てるのは簡単じゃないか？
問題は、
ノードの数が変わった場合、
ほとんどのキーは他のノードに移さなくてはならなくなる、ということ。
たとえば、
hash(key) = 123456
だとする。
ノード数10 →123456 mod 10 = 6
ノード数11 →123456 mod 11 = 3
ノード数11 →123456 mod 12 = 0
ノード数が変わるたび、該当キーを別ノードに移さなくてはならない。
これは使えない。

■■■■■■■■■■■■■■■■■■■■■■■■■■ Fixed number of partitions
・シンプルな解決策
ノードよりずっとたくさんのパーティションを作る。
で、
複数のパーティションを各ノードに割り当てる

たとえば、
1クラスタ10ノードのデータベースを、
最初は 1000 のパーティションにわける。
そうすると、
各ノードにだいたい 100 パーティションずつ割り当てられる。

で、
クラスターにノードが追加されるとする。
そしてそのノードは、
既存のノードから、全ノードのパーティションが均等に分散されるように、それぞれ少しずつパーティションを譲り受ける。

で、
クラスタからノードが削除されるとする。
追加時と逆のことが行われる。

パーティション全体が、ノード間で移動するだけで、
パーティションの数は変わらないし、
パーティションへのキーの割当も変わらない。
変わるのは、
ノードに対するパーティションの割当だけ。
この割当変更は即座には行われない。
大量のデータをネットワーク越しに転送するのには時間がかかる。
よって、
転送中に発生する全ての読み書きに、旧パーティション割当が使われる。

実際は、
クラスタ内のHWのスペック違い等も考慮にいれたりする。
パワフルなノードにはよりたくさんのパーティションを割り当てるなど。
このアプローチは、下記で使われている。
Riak [15], Elasticsearch [24], Couchbase [10], and Voldemort [25].

で、パーティション自体の数はDBが最初にセットアップされた時点からずっと固定。
実際には、
パーティションを分割したりマージしたりする可能性もあるが、
数固定の方がシンプルだし、パーティション分かつを実装していないDBはたくさんある。

そんなわけで、
最初に決めるパーティションの数は、保持できる最大ノード数を考慮して、
将来の成長を収納するに十分な数にする必要がある。
だがしかし、
各パーティションには管理オーバーヘッドがあるので、多すぎてもよくない。

各パーティションは、a fixed fraction of the total data を含むので、
各パーティションのサイズはクラスタ内の総データ量に比例して増減する。

パーティションが大きすぎればリバランシングやノードのfailure からの復帰が高コストになるし、
小さすぎればオーバーヘッドが発生する。
