■■■■■■■■■■■■■■■■■■■■■■■■■■ Single-Object and Multi-Object Operations
atomicity and isolation は、クライアントが複数の書き込みを同じトランザクション内で行ったときに、
DBがすべきことを表現している

つまり、複数の objects (rows, documents, records) に変更を加えることを念頭においている。
マルチオブジェクトトランザクションは複数のデータが need to be kept in sync な時に行われる。

例)メールアプリ
あるユーザーの未読件数を表示するには、下記のようなクエリがなされる。

SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true

そしてこう感じたとする
このクエリは遅すぎる。メール数が多すぎるからだ。
で、
未読メッセージ数を個別のフィールドに格納するとする
// 一種の 非正規化
以降は、
新規メール受信時は、未読カウントをインクリメントし、
メッセージを呼んだときは、未読カウンターをデクリメントする。

そこで、ユーザー2 がおかしな経験をする。
メールボックスを見ると、未読メッセージがある。
しかし、
未読カウンターはゼロのまま
みたいな。なぜなら、カウンターのインクリメントがまだ起きていないから。

▼ Isolation が機能する
Isolation が、上記現象を防ぐ。
ユーザー2の視点では、新規メールを受信したこととカウンタ更新の両方を同時に見るか、どちらも見ないかのいずれかしか起きない。
その中間はありえない。

別のケース)
トランザクションの途中でエラーが発生したとする。
メールボックスの中身と、カウンターとが同期していない自体になる。

▼ atomicity が機能する
アトミックなトランザクションでは、
もしカウンタの更新が失敗したら、トランザクションは破棄され、新規メールのメールボックスへの挿入はロールバックされる。
-------------------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■ マルチOBJ トランザクションは、下記を判別する方法が必要
ある読み書きオペレーションが同じトランザクションに属するかどうか。

・RDB では、上記はクライアントとDBサーバとの間のTCPコネクションに基づいて実現される。
ある特定の接続の間は、
a BEGIN TRANSACTION and a COMMIT statement の間の全ては同じトランザクションの一部と判断される。
※ とはいえ、これは理想的ではない。
もしTCP接続が中断された場合、トランザクションは破棄されなければならない。
もしクライアントがコミットをリクエストしたあとで、かつサーバーがそのコミットが発生したことを acknowledges する前に中断が発生したら、
クライアントはトランザクションがコミットされたかどうか知ることができない。
上記問題を解決するために、
a transaction manager が、オペレーションを、トランザクションIDによってグループ化する方法がある。

・一方、多くの RDB ではない DBは、オペレーションをグループ化する方法がない。
たとえ、multi-object API があったとしても、
(そのキーバリューストアは、一つのオペで複数のキーを更新したりといった、マルチプットができるようになっているとか。)
だったとしても、
トランザクションの セマンティクス(意味論)がなくてはいけない、とはならない。
そのコマンドはあるキーに対しては成功して、他のキーには失敗するかもしれない。
で、
DBは部分的に更新された状態になるかもしれない。

■■■■■■■■■■■■■■■■■■■■■■■■■■ Single-object writes
Atomicity and isolation は、単一のOBJ が変更されたときにも適用される。
例えば、
ある 20 KB のJSONドキュメントをDBに書き込むとする。
・もし、最初ん 10KB が送られたあとでネットワーク中断が起きたとして、DBはパースできないJSONの断片を格納するのか？
・DBがディスク上の値を上書きしている途中で電源が落ちた場合、古い値をどうするんだ？
・あるユーザーが書き込みしている途中で他のクライアントが読み込みしたとき、一部更新の値をそのクライアントは読み込むのか？
上記、対処は大変なので、ストレージエンジンは、単一ノード上のシングルOBJ(一つのキーバリューペアとか)のレベルで、 A と I とがなされるようにしている。

Atomicity はログを使って実装することができる。// クラッシュしても復元できる方法
Isolation は各OBJをロックすることで実装できる// 一つのOBJに同時にアクセスできるのは一つのスレッドのみ

■ トランザクションの仲間とされているが、それはミスリーディングだ。
▼ increment operation
・複雑な Atomic オペレーションの例。
・read-modify-write サイクルが不要になる。
※ ここで使われる atomic increment という用語の atomic は、マルチスレッドプログラミングにおける atomic だったりする。
ACID 文脈でいくと、isolated or serializable increment の方がより正確だけれども、But that’s getting nitpicky.

▼ compare-and-set operation
書き込みが成功するのは、他の誰かが同時に書き込みをしていない場合に限る。

ここまでみてきた single-object operations は有効だ。
複数のクライアントが同じOBJに同時書き込もうとしたときの ロストアップデートを防ぐことができるから。
しかし、
こいつらは通常使う感覚でのトランザクションとは異なる。
時にこれらは
“light‐ weight transactions” だったり ACID であると言及されたりもするが、
ミスリーディングな言い方だ。

▼ トランザクションとは// 再び
トランザクションとはどんなメカニズムなのか。
複数のOBJに対する複数のオペレーションを、単一の実行にグループ化することだ。


■■■■■■■■■■■■■■■■■■■■■■■■■■ The need for multi-object transactions
多くの分散データストアは multi-object transactions を廃止した。
なぜか。
複数のパーティションをまたいで実装することが難しいから。
そして、
and they can get in the way in some scenarios
where very high availability or performance is required.

だがしかし、
分散DBにおいてトランザクションを妨げる根本的原因、みたいなものは存在しない。
その実装方法については後述する。

だがだが、
そもそも multi-object transactions なんて必要なのか？
キーバリューモデルしか使っていなくて、
単一OBJ オペレーションしかないアプリに対して、実装するとか、ありなのか？

single-object inserts, updates, and deletes で十分なユースケースもたくさんある。
だが、
多くのケースでは、複数の異なるOBJへの書き込みが必要である。

・RDBでは、あるテーブルの行は、他のテーブルの行への外部キー参照を持ってたりする。
※ グラフデータモデルでも、vertex は他の vertex への エッジを持ってたりする
マルチOBJ トランザクションは、それら参照が valid なままであることを保証できる。
互いに参照しあってる複数のレコードを挿入するとき、
外部キーはUpToDateでなければならない。
でなければ、無意味なデータになる。

・ドキュメントデータモデルでは、
一緒に更新する必要があるフィールドはたいてい同じドキュメント内にある。
そしてそれはシングルOBJとして取り扱われるため、
単一ドキュメントを更新するときにはマルチOBJ トランザクションは必要とされない。

だがしかし、
ドキュメントDBは JOIN 機能がないので、非正規化が必要だったりする。
非正規化された情報を更新するときには、
複数のドキュメントを一度に更新する必要がある。
そんな時にトランザクションは役立つ。
非正規化データが同期から外れることを防いでくれる。

・セカンダリインデックスのあるDBは、値が変わるたびにインデックスも更新される必要がある。

▼ トランザクションとインデックス
トランザクション視点で見ると、インデックスは別のOBJである。
例えば、
トランザクションにおける isolation がないと、
セカンダリインデックスがまだ更新されていないから、といった事が原因で、
あるレコードがあるインデックスには登場し、他のレコードには登場しない、ということが起こりうる。
-------------------------------------------------
上記のようなアプリも、トランザクション無しで実装できないことはない。
だがしかし、
エラーハンドリングはアトミシティなしではずっと複雑だし、
Isolation がないと concurrency の問題が起こりうる。
